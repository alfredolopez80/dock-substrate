#![feature(prelude_import)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
extern crate alloc;
use codec::{Decode, Encode};
/// Any state change that needs to be signed is first wrapped in this enum and then its serialized.
/// This is done to prevent make it unambiguous which command was intended as the SCALE codec's
/// not self describing.
/// Never change the order of variants in this enum
pub enum StateChange {
    KeyUpdate(did::KeyUpdate),
    DIDRemoval(did::DidRemoval),
    Revoke(revoke::Revoke),
    UnRevoke(revoke::UnRevoke),
    RemoveRegistry(revoke::RemoveRegistry),
    Blob(blob::Blob),
    MasterVote(master::Payload),
}
const _: () = {
    #[allow(unknown_lints)]
    #[allow(rust_2018_idioms)]
    extern crate codec as _parity_scale_codec;
    impl _parity_scale_codec::Encode for StateChange {
        fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
            &self,
            __codec_dest_edqy: &mut __CodecOutputEdqy,
        ) {
            match *self {
                StateChange::KeyUpdate(ref aa) => {
                    __codec_dest_edqy.push_byte(0usize as u8);
                    __codec_dest_edqy.push(aa);
                }
                StateChange::DIDRemoval(ref aa) => {
                    __codec_dest_edqy.push_byte(1usize as u8);
                    __codec_dest_edqy.push(aa);
                }
                StateChange::Revoke(ref aa) => {
                    __codec_dest_edqy.push_byte(2usize as u8);
                    __codec_dest_edqy.push(aa);
                }
                StateChange::UnRevoke(ref aa) => {
                    __codec_dest_edqy.push_byte(3usize as u8);
                    __codec_dest_edqy.push(aa);
                }
                StateChange::RemoveRegistry(ref aa) => {
                    __codec_dest_edqy.push_byte(4usize as u8);
                    __codec_dest_edqy.push(aa);
                }
                StateChange::Blob(ref aa) => {
                    __codec_dest_edqy.push_byte(5usize as u8);
                    __codec_dest_edqy.push(aa);
                }
                StateChange::MasterVote(ref aa) => {
                    __codec_dest_edqy.push_byte(6usize as u8);
                    __codec_dest_edqy.push(aa);
                }
                _ => (),
            }
        }
    }
    impl _parity_scale_codec::EncodeLike for StateChange {}
};
const _: () = {
    #[allow(unknown_lints)]
    #[allow(rust_2018_idioms)]
    extern crate codec as _parity_scale_codec;
    impl _parity_scale_codec::Decode for StateChange {
        fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
            __codec_input_edqy: &mut __CodecInputEdqy,
        ) -> core::result::Result<Self, _parity_scale_codec::Error> {
            match __codec_input_edqy.read_byte()? {
                __codec_x_edqy if __codec_x_edqy == 0usize as u8 => Ok(StateChange::KeyUpdate({
                    let __codec_res_edqy = _parity_scale_codec::Decode::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        Err(_) => {
                            return Err("Error decoding field StateChange :: KeyUpdate.0".into())
                        }
                        Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                })),
                __codec_x_edqy if __codec_x_edqy == 1usize as u8 => Ok(StateChange::DIDRemoval({
                    let __codec_res_edqy = _parity_scale_codec::Decode::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        Err(_) => {
                            return Err("Error decoding field StateChange :: DIDRemoval.0".into())
                        }
                        Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                })),
                __codec_x_edqy if __codec_x_edqy == 2usize as u8 => Ok(StateChange::Revoke({
                    let __codec_res_edqy = _parity_scale_codec::Decode::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        Err(_) => return Err("Error decoding field StateChange :: Revoke.0".into()),
                        Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                })),
                __codec_x_edqy if __codec_x_edqy == 3usize as u8 => Ok(StateChange::UnRevoke({
                    let __codec_res_edqy = _parity_scale_codec::Decode::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        Err(_) => {
                            return Err("Error decoding field StateChange :: UnRevoke.0".into())
                        }
                        Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                })),
                __codec_x_edqy if __codec_x_edqy == 4usize as u8 => {
                    Ok(StateChange::RemoveRegistry({
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err(
                                    "Error decoding field StateChange :: RemoveRegistry.0".into()
                                )
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    }))
                }
                __codec_x_edqy if __codec_x_edqy == 5usize as u8 => Ok(StateChange::Blob({
                    let __codec_res_edqy = _parity_scale_codec::Decode::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        Err(_) => return Err("Error decoding field StateChange :: Blob.0".into()),
                        Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                })),
                __codec_x_edqy if __codec_x_edqy == 6usize as u8 => Ok(StateChange::MasterVote({
                    let __codec_res_edqy = _parity_scale_codec::Decode::decode(__codec_input_edqy);
                    match __codec_res_edqy {
                        Err(_) => {
                            return Err("Error decoding field StateChange :: MasterVote.0".into())
                        }
                        Ok(__codec_res_edqy) => __codec_res_edqy,
                    }
                })),
                _ => Err("No such variant in enum StateChange".into()),
            }
        }
    }
};
pub type BlockNumber = u32;
pub mod anchor {
    //! Minimal proof of existence registry.
    //!
    //! Anchors are hashed once before being added to storage. To check whether an anchor exists
    //! query the "Anchors" map for the hash of the anchor. If a corresponding value exists, then the
    //! anchor exists and the value represents the block number when it was first published.
    use alloc::vec::Vec;
    use frame_support::{
        decl_error, decl_event, decl_module, decl_storage, dispatch::DispatchResult, ensure,
        traits::Get,
    };
    use frame_system::{self as system, ensure_signed};
    use sp_runtime::traits::Hash;
    pub trait Trait: system::Config {
        type Event: From<Event<Self>> + Into<<Self as system::Config>::Event>;
    }
    pub enum Error<T: Trait> {
        #[doc(hidden)]
        __Ignore(
            ::frame_support::sp_std::marker::PhantomData<(T,)>,
            ::frame_support::Never,
        ),
        /// The anchor being posted was already created in a previous block.
        AnchorExists,
    }
    impl<T: Trait> ::frame_support::sp_std::fmt::Debug for Error<T> {
        fn fmt(
            &self,
            f: &mut ::frame_support::sp_std::fmt::Formatter<'_>,
        ) -> ::frame_support::sp_std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl<T: Trait> Error<T> {
        fn as_u8(&self) -> u8 {
            match self {
                Error::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"`__Ignore` can never be constructed",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Error::AnchorExists => 0,
            }
        }
        fn as_str(&self) -> &'static str {
            match self {
                Self::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"`__Ignore` can never be constructed",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Error::AnchorExists => "AnchorExists",
            }
        }
    }
    impl<T: Trait> From<Error<T>> for &'static str {
        fn from(err: Error<T>) -> &'static str {
            err.as_str()
        }
    }
    impl<T: Trait> From<Error<T>> for ::frame_support::sp_runtime::DispatchError {
        fn from(err: Error<T>) -> Self {
            let index = <T::PalletInfo as ::frame_support::traits::PalletInfo>::index::<Module<T>>()
                .expect("Every active module has an index in the runtime; qed")
                as u8;
            ::frame_support::sp_runtime::DispatchError::Module {
                index,
                error: err.as_u8(),
                message: Some(err.as_str()),
            }
        }
    }
    impl<T: Trait> ::frame_support::error::ModuleErrorMetadata for Error<T> {
        fn metadata() -> &'static [::frame_support::error::ErrorMetadata] {
            &[::frame_support::error::ErrorMetadata {
                name: ::frame_support::error::DecodeDifferent::Encode("AnchorExists"),
                documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                    r" The anchor being posted was already created in a previous block.",
                ]),
            }]
        }
    }
    use self::sp_api_hidden_includes_decl_storage::hidden_include::{
        StorageValue as _, StorageMap as _, StorageDoubleMap as _, StoragePrefixedMap as _,
        IterableStorageMap as _, IterableStorageDoubleMap as _,
    };
    #[doc(hidden)]
    mod sp_api_hidden_includes_decl_storage {
        pub extern crate frame_support as hidden_include;
    }
    trait Store {
        type Anchors;
    }
    impl<T: Trait + 'static> Store for Module<T> {
        type Anchors = Anchors<T>;
    }
    impl<T: Trait + 'static> Module<T> {}
    #[doc(hidden)]
    pub struct __GetByteStructAnchors<T>(
        pub  self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<
            (T),
        >,
    );
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_Anchors:
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<
            self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>,
        > =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl<T: Trait> self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
        for __GetByteStructAnchors<T>
    {
        fn default_byte(
            &self,
        ) -> self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>
        {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_Anchors
                .get_or_init(|| {
                    let def_val: Option<<T as system::Config>::BlockNumber> = Default::default();
                    <Option<<T as system::Config>::BlockNumber> as Encode>::encode(&def_val)
                })
                .clone()
        }
    }
    unsafe impl<T: Trait> Send for __GetByteStructAnchors<T> {}
    unsafe impl<T: Trait> Sync for __GetByteStructAnchors<T> {}
    impl<T: Trait + 'static> Module<T> {
        #[doc(hidden)]
        pub fn storage_metadata(
        ) -> self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageMetadata
        {
            self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageMetadata { prefix : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("Anchor") , entries : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (& [self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryMetadata { name : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("Anchors") , modifier : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryModifier :: Optional , ty : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryType :: Map { hasher : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageHasher :: Identity , key : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("<T as system::Config>::Hash") , value : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("<T as system::Config>::BlockNumber") , unused : false , } , default : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DefaultByteGetter (& __GetByteStructAnchors :: < T > (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_std :: marker :: PhantomData))) , documentation : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (& []) , }] [..]) , }
        }
    }
    /// Hidden instance generated to be internally used when module is used without
    /// instance.
    #[doc(hidden)]
    pub struct __InherentHiddenInstance;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for __InherentHiddenInstance {
        #[inline]
        fn clone(&self) -> __InherentHiddenInstance {
            match *self {
                __InherentHiddenInstance => __InherentHiddenInstance,
            }
        }
    }
    impl ::core::marker::StructuralEq for __InherentHiddenInstance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for __InherentHiddenInstance {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    impl ::core::marker::StructuralPartialEq for __InherentHiddenInstance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for __InherentHiddenInstance {
        #[inline]
        fn eq(&self, other: &__InherentHiddenInstance) -> bool {
            match *other {
                __InherentHiddenInstance => match *self {
                    __InherentHiddenInstance => true,
                },
            }
        }
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for __InherentHiddenInstance {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
            }
        }
        impl _parity_scale_codec::EncodeLike for __InherentHiddenInstance {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for __InherentHiddenInstance {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(__InherentHiddenInstance)
            }
        }
    };
    impl core::fmt::Debug for __InherentHiddenInstance {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("__InherentHiddenInstance").finish()
        }
    }
    impl self::sp_api_hidden_includes_decl_storage::hidden_include::traits::Instance
        for __InherentHiddenInstance
    {
        const PREFIX: &'static str = "Anchor";
    }
    struct Anchors<T: Trait>(
        self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<
                (T,),
            >,
    );
    impl<T: Trait>
        self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StoragePrefixedMap<
            <T as system::Config>::BlockNumber,
        > for Anchors<T>
    {
        fn module_prefix() -> &'static [u8] {
            < __InherentHiddenInstance as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > :: PREFIX . as_bytes ()
        }
        fn storage_prefix() -> &'static [u8] {
            b"Anchors"
        }
    }
    impl<T: Trait>
        self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<
            <T as system::Config>::Hash,
            <T as system::Config>::BlockNumber,
        > for Anchors<T>
    {
        type Query = Option<<T as system::Config>::BlockNumber>;
        type Hasher = self::sp_api_hidden_includes_decl_storage::hidden_include::Identity;
        fn module_prefix() -> &'static [u8] {
            < __InherentHiddenInstance as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > :: PREFIX . as_bytes ()
        }
        fn storage_prefix() -> &'static [u8] {
            b"Anchors"
        }
        fn from_optional_value_to_query(
            v: Option<<T as system::Config>::BlockNumber>,
        ) -> Self::Query {
            v.or_else(|| Default::default())
        }
        fn from_query_to_optional_value(
            v: Self::Query,
        ) -> Option<<T as system::Config>::BlockNumber> {
            v
        }
    }
    /// [`RawEvent`] specialized for the configuration [`Config`]
    ///
    /// [`RawEvent`]: enum.RawEvent.html
    /// [`Config`]: trait.Config.html
    pub type Event<T> = RawEvent<
        <T as system::Config>::AccountId,
        <T as system::Config>::BlockNumber,
        <T as system::Config>::Hash,
    >;
    /// Events for this module.
    ///
    pub enum RawEvent<AccountId, BlockNumber, Hash> {
        /// A new permanent anchor was posted.
        AnchorDeployed(Hash, AccountId, BlockNumber),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<
            AccountId: ::core::clone::Clone,
            BlockNumber: ::core::clone::Clone,
            Hash: ::core::clone::Clone,
        > ::core::clone::Clone for RawEvent<AccountId, BlockNumber, Hash>
    {
        #[inline]
        fn clone(&self) -> RawEvent<AccountId, BlockNumber, Hash> {
            match (&*self,) {
                (&RawEvent::AnchorDeployed(ref __self_0, ref __self_1, ref __self_2),) => {
                    RawEvent::AnchorDeployed(
                        ::core::clone::Clone::clone(&(*__self_0)),
                        ::core::clone::Clone::clone(&(*__self_1)),
                        ::core::clone::Clone::clone(&(*__self_2)),
                    )
                }
            }
        }
    }
    impl<AccountId, BlockNumber, Hash> ::core::marker::StructuralPartialEq
        for RawEvent<AccountId, BlockNumber, Hash>
    {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<
            AccountId: ::core::cmp::PartialEq,
            BlockNumber: ::core::cmp::PartialEq,
            Hash: ::core::cmp::PartialEq,
        > ::core::cmp::PartialEq for RawEvent<AccountId, BlockNumber, Hash>
    {
        #[inline]
        fn eq(&self, other: &RawEvent<AccountId, BlockNumber, Hash>) -> bool {
            match (&*self, &*other) {
                (
                    &RawEvent::AnchorDeployed(ref __self_0, ref __self_1, ref __self_2),
                    &RawEvent::AnchorDeployed(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),
                ) => {
                    (*__self_0) == (*__arg_1_0)
                        && (*__self_1) == (*__arg_1_1)
                        && (*__self_2) == (*__arg_1_2)
                }
            }
        }
        #[inline]
        fn ne(&self, other: &RawEvent<AccountId, BlockNumber, Hash>) -> bool {
            match (&*self, &*other) {
                (
                    &RawEvent::AnchorDeployed(ref __self_0, ref __self_1, ref __self_2),
                    &RawEvent::AnchorDeployed(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),
                ) => {
                    (*__self_0) != (*__arg_1_0)
                        || (*__self_1) != (*__arg_1_1)
                        || (*__self_2) != (*__arg_1_2)
                }
            }
        }
    }
    impl<AccountId, BlockNumber, Hash> ::core::marker::StructuralEq
        for RawEvent<AccountId, BlockNumber, Hash>
    {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<AccountId: ::core::cmp::Eq, BlockNumber: ::core::cmp::Eq, Hash: ::core::cmp::Eq>
        ::core::cmp::Eq for RawEvent<AccountId, BlockNumber, Hash>
    {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<Hash>;
                let _: ::core::cmp::AssertParamIsEq<AccountId>;
                let _: ::core::cmp::AssertParamIsEq<BlockNumber>;
            }
        }
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl<AccountId, BlockNumber, Hash> _parity_scale_codec::Encode
            for RawEvent<AccountId, BlockNumber, Hash>
        where
            Hash: _parity_scale_codec::Encode,
            Hash: _parity_scale_codec::Encode,
            AccountId: _parity_scale_codec::Encode,
            AccountId: _parity_scale_codec::Encode,
            BlockNumber: _parity_scale_codec::Encode,
            BlockNumber: _parity_scale_codec::Encode,
        {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    RawEvent::AnchorDeployed(ref aa, ref ba, ref ca) => {
                        __codec_dest_edqy.push_byte(0usize as u8);
                        __codec_dest_edqy.push(aa);
                        __codec_dest_edqy.push(ba);
                        __codec_dest_edqy.push(ca);
                    }
                    _ => (),
                }
            }
        }
        impl<AccountId, BlockNumber, Hash> _parity_scale_codec::EncodeLike
            for RawEvent<AccountId, BlockNumber, Hash>
        where
            Hash: _parity_scale_codec::Encode,
            Hash: _parity_scale_codec::Encode,
            AccountId: _parity_scale_codec::Encode,
            AccountId: _parity_scale_codec::Encode,
            BlockNumber: _parity_scale_codec::Encode,
            BlockNumber: _parity_scale_codec::Encode,
        {
        }
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl<AccountId, BlockNumber, Hash> _parity_scale_codec::Decode
            for RawEvent<AccountId, BlockNumber, Hash>
        where
            Hash: _parity_scale_codec::Decode,
            Hash: _parity_scale_codec::Decode,
            AccountId: _parity_scale_codec::Decode,
            AccountId: _parity_scale_codec::Decode,
            BlockNumber: _parity_scale_codec::Decode,
            BlockNumber: _parity_scale_codec::Decode,
        {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                match __codec_input_edqy.read_byte()? {
                    __codec_x_edqy if __codec_x_edqy == 0usize as u8 => {
                        Ok(RawEvent::AnchorDeployed(
                            {
                                let __codec_res_edqy =
                                    _parity_scale_codec::Decode::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    Err(_) => {
                                        return Err(
                                            "Error decoding field RawEvent :: AnchorDeployed.0"
                                                .into(),
                                        )
                                    }
                                    Ok(__codec_res_edqy) => __codec_res_edqy,
                                }
                            },
                            {
                                let __codec_res_edqy =
                                    _parity_scale_codec::Decode::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    Err(_) => {
                                        return Err(
                                            "Error decoding field RawEvent :: AnchorDeployed.1"
                                                .into(),
                                        )
                                    }
                                    Ok(__codec_res_edqy) => __codec_res_edqy,
                                }
                            },
                            {
                                let __codec_res_edqy =
                                    _parity_scale_codec::Decode::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    Err(_) => {
                                        return Err(
                                            "Error decoding field RawEvent :: AnchorDeployed.2"
                                                .into(),
                                        )
                                    }
                                    Ok(__codec_res_edqy) => __codec_res_edqy,
                                }
                            },
                        ))
                    }
                    _ => Err("No such variant in enum RawEvent".into()),
                }
            }
        }
    };
    impl<AccountId, BlockNumber, Hash> core::fmt::Debug for RawEvent<AccountId, BlockNumber, Hash>
    where
        AccountId: core::fmt::Debug,
        BlockNumber: core::fmt::Debug,
        Hash: core::fmt::Debug,
    {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self {
                Self::AnchorDeployed(ref a0, ref a1, ref a2) => fmt
                    .debug_tuple("RawEvent::AnchorDeployed")
                    .field(a0)
                    .field(a1)
                    .field(a2)
                    .finish(),
                _ => Ok(()),
            }
        }
    }
    impl<AccountId, BlockNumber, Hash> From<RawEvent<AccountId, BlockNumber, Hash>> for () {
        fn from(_: RawEvent<AccountId, BlockNumber, Hash>) -> () {
            ()
        }
    }
    impl<AccountId, BlockNumber, Hash> RawEvent<AccountId, BlockNumber, Hash> {
        #[allow(dead_code)]
        #[doc(hidden)]
        pub fn metadata() -> &'static [::frame_support::event::EventMetadata] {
            &[::frame_support::event::EventMetadata {
                name: ::frame_support::event::DecodeDifferent::Encode("AnchorDeployed"),
                arguments: ::frame_support::event::DecodeDifferent::Encode(&[
                    "Hash",
                    "AccountId",
                    "BlockNumber",
                ]),
                documentation: ::frame_support::event::DecodeDifferent::Encode(&[
                    r" A new permanent anchor was posted.",
                ]),
            }]
        }
    }
    pub struct Module<T: Trait>(::frame_support::sp_std::marker::PhantomData<(T,)>);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::clone::Clone + Trait> ::core::clone::Clone for Module<T> {
        #[inline]
        fn clone(&self) -> Module<T> {
            match *self {
                Module(ref __self_0_0) => Module(::core::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::marker::Copy + Trait> ::core::marker::Copy for Module<T> {}
    impl<T: Trait> ::core::marker::StructuralPartialEq for Module<T> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::cmp::PartialEq + Trait> ::core::cmp::PartialEq for Module<T> {
        #[inline]
        fn eq(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) => match *self {
                    Module(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) => match *self {
                    Module(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl<T: Trait> ::core::marker::StructuralEq for Module<T> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::cmp::Eq + Trait> ::core::cmp::Eq for Module<T> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<
                    ::frame_support::sp_std::marker::PhantomData<(T,)>,
                >;
            }
        }
    }
    impl<T: Trait> core::fmt::Debug for Module<T>
    where
        T: core::fmt::Debug,
    {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("Module").field(&self.0).finish()
        }
    }
    impl<T: frame_system::Config + Trait>
        ::frame_support::traits::OnInitialize<<T as frame_system::Config>::BlockNumber>
        for Module<T>
    {
    }
    impl<T: Trait> ::frame_support::traits::OnRuntimeUpgrade for Module<T> {
        fn on_runtime_upgrade() -> ::frame_support::dispatch::Weight {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "on_runtime_upgrade",
                            "core_mods::anchor",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/anchor.rs"),
                            Some(47u32),
                            Some("core_mods::anchor"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
            .put_into_storage::<<T as frame_system::Config>::PalletInfo, Self>();
            <<T as frame_system::Config>::DbWeight as ::frame_support::traits::Get<_>>::get()
                .writes(1)
        }
    }
    impl<T: frame_system::Config + Trait>
        ::frame_support::traits::OnFinalize<<T as frame_system::Config>::BlockNumber>
        for Module<T>
    {
    }
    impl<T: frame_system::Config + Trait>
        ::frame_support::traits::OffchainWorker<<T as frame_system::Config>::BlockNumber>
        for Module<T>
    {
    }
    impl<T: Trait> Module<T> {
        /// Deposits an event using `frame_system::Module::deposit_event`.
        fn deposit_event(event: impl Into<<T as Trait>::Event>) {
            <frame_system::Module<T>>::deposit_event(event.into())
        }
    }
    #[cfg(feature = "std")]
    impl<T: Trait> ::frame_support::traits::IntegrityTest for Module<T> {}
    /// Can also be called using [`Call`].
    ///
    /// [`Call`]: enum.Call.html
    impl<T: Trait> Module<T> {
        /// Drop a permanent anchor.
        ///
        /// NOTE: Calling this function will bypass origin filters.
        pub fn deploy(origin: T::Origin, dat: Vec<u8>) -> DispatchResult {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "deploy",
                            "core_mods::anchor",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/anchor.rs"),
                            Some(47u32),
                            Some("core_mods::anchor"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            Module::<T>::deploy_(origin, dat)
        }
    }
    /// Dispatchable calls.
    ///
    /// Each variant of this enum maps to a dispatchable function from the associated module.
    pub enum Call<T: Trait> {
        #[doc(hidden)]
        #[codec(skip)]
        __PhantomItem(
            ::frame_support::sp_std::marker::PhantomData<(T,)>,
            ::frame_support::Never,
        ),
        #[allow(non_camel_case_types)]
        /// Drop a permanent anchor.
        deploy(Vec<u8>),
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl<T: Trait> _parity_scale_codec::Encode for Call<T> {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    Call::deploy(ref aa) => {
                        __codec_dest_edqy.push_byte(0usize as u8);
                        __codec_dest_edqy.push(aa);
                    }
                    _ => (),
                }
            }
        }
        impl<T: Trait> _parity_scale_codec::EncodeLike for Call<T> {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl<T: Trait> _parity_scale_codec::Decode for Call<T> {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                match __codec_input_edqy.read_byte()? {
                    __codec_x_edqy if __codec_x_edqy == 0usize as u8 => Ok(Call::deploy({
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Call :: deploy.0".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    })),
                    _ => Err("No such variant in enum Call".into()),
                }
            }
        }
    };
    impl<T: Trait> ::frame_support::dispatch::GetDispatchInfo for Call<T> {
        fn get_dispatch_info(&self) -> ::frame_support::dispatch::DispatchInfo {
            match *self {
                Call::deploy(ref dat) => {
                    let base_weight = T::DbWeight::get().reads_writes(1, 1);
                    let weight =
                        <dyn ::frame_support::dispatch::WeighData<(&Vec<u8>,)>>::weigh_data(
                            &base_weight,
                            (dat,),
                        );
                    let class = < dyn :: frame_support :: dispatch :: ClassifyDispatch < (& Vec < u8 > ,) > > :: classify_dispatch (& base_weight , (dat ,)) ;
                    let pays_fee = <dyn ::frame_support::dispatch::PaysFee<(&Vec<u8>,)>>::pays_fee(
                        &base_weight,
                        (dat,),
                    );
                    ::frame_support::dispatch::DispatchInfo {
                        weight,
                        class,
                        pays_fee,
                    }
                }
                Call::__PhantomItem(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__PhantomItem should never be used.",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::GetCallName for Call<T> {
        fn get_call_name(&self) -> &'static str {
            match *self {
                Call::deploy(ref dat) => {
                    let _ = (dat);
                    "deploy"
                }
                Call::__PhantomItem(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__PhantomItem should never be used.",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
        fn get_call_names() -> &'static [&'static str] {
            &["deploy"]
        }
    }
    pub use ::frame_support::traits::GetPalletVersion as _;
    impl<T: Trait> ::frame_support::traits::GetPalletVersion for Module<T> {
        fn current_version() -> ::frame_support::traits::PalletVersion {
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
        }
        fn storage_version() -> Option<::frame_support::traits::PalletVersion> {
            let key = ::frame_support::traits::PalletVersion::storage_key::<
                <T as frame_system::Config>::PalletInfo,
                Self,
            >()
            .expect("Every active pallet has a name in the runtime; qed");
            ::frame_support::storage::unhashed::get(&key)
        }
    }
    impl<T: Trait> ::frame_support::traits::OnGenesis for Module<T> {
        fn on_genesis() {
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
            .put_into_storage::<<T as frame_system::Config>::PalletInfo, Self>();
        }
    }
    impl<T: Trait> ::frame_support::dispatch::Clone for Call<T> {
        fn clone(&self) -> Self {
            match *self {
                Call::deploy(ref dat) => Call::deploy((*dat).clone()),
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::PartialEq for Call<T> {
        fn eq(&self, _other: &Self) -> bool {
            match *self {
                Call::deploy(ref dat) => {
                    let self_params = (dat,);
                    if let Call::deploy(ref dat) = *_other {
                        self_params == (dat,)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                ::core::panicking::panic("internal error: entered unreachable code")
                            }
                            _ => false,
                        }
                    }
                }
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::Eq for Call<T> {}
    impl<T: Trait> ::frame_support::dispatch::fmt::Debug for Call<T> {
        fn fmt(
            &self,
            _f: &mut ::frame_support::dispatch::fmt::Formatter,
        ) -> ::frame_support::dispatch::result::Result<(), ::frame_support::dispatch::fmt::Error>
        {
            match *self {
                Call::deploy(ref dat) => _f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", ""],
                    &match (&"deploy", &(dat.clone(),)) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                        ],
                    },
                )),
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
    }
    impl<T: Trait> ::frame_support::traits::UnfilteredDispatchable for Call<T> {
        type Origin = T::Origin;
        fn dispatch_bypass_filter(
            self,
            _origin: Self::Origin,
        ) -> ::frame_support::dispatch::DispatchResultWithPostInfo {
            match self {
                Call::deploy(dat) => <Module<T>>::deploy(_origin, dat)
                    .map(Into::into)
                    .map_err(Into::into),
                Call::__PhantomItem(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__PhantomItem should never be used.",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::Callable<T> for Module<T> {
        type Call = Call<T>;
    }
    impl<T: Trait> Module<T> {
        #[doc(hidden)]
        #[allow(dead_code)]
        pub fn call_functions() -> &'static [::frame_support::dispatch::FunctionMetadata] {
            &[::frame_support::dispatch::FunctionMetadata {
                name: ::frame_support::dispatch::DecodeDifferent::Encode("deploy"),
                arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                    ::frame_support::dispatch::FunctionArgumentMetadata {
                        name: ::frame_support::dispatch::DecodeDifferent::Encode("dat"),
                        ty: ::frame_support::dispatch::DecodeDifferent::Encode("Vec<u8>"),
                    },
                ]),
                documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                    r" Drop a permanent anchor.",
                ]),
            }]
        }
    }
    impl<T: 'static + Trait> Module<T> {
        #[doc(hidden)]
        #[allow(dead_code)]
        pub fn module_constants_metadata(
        ) -> &'static [::frame_support::dispatch::ModuleConstantMetadata] {
            &[]
        }
    }
    impl<T: Trait> ::frame_support::dispatch::ModuleErrorMetadata for Module<T> {
        fn metadata() -> &'static [::frame_support::dispatch::ErrorMetadata] {
            <&'static str as ::frame_support::dispatch::ModuleErrorMetadata>::metadata()
        }
    }
    impl<T: Trait> Module<T> {
        fn deploy_(origin: <T as system::Config>::Origin, dat: Vec<u8>) -> DispatchResult {
            let acct = ensure_signed(origin)?;
            let h = <T as system::Config>::Hashing::hash(&dat);
            {
                if !Anchors::<T>::get(&h).is_none() {
                    {
                        return Err(Error::<T>::AnchorExists.into());
                    };
                }
            };
            let bn = <system::Module<T>>::block_number();
            Anchors::<T>::insert(&h, &bn);
            Self::deposit_event(Event::<T>::AnchorDeployed(h, acct, bn));
            Ok(())
        }
    }
}
pub mod blob {
    //! Generic immutable single-owner storage.
    use crate as dock;
    use crate::did;
    use alloc::vec::Vec;
    use codec::{Decode, Encode};
    use frame_support::{
        decl_error, decl_module, decl_storage, dispatch::DispatchResult, ensure, traits::Get,
        weights::Weight,
    };
    use frame_system::{self as system, ensure_signed};
    /// Size of the blob id in bytes
    pub const ID_BYTE_SIZE: usize = 32;
    /// The unique name for a blob.
    pub type BlobId = [u8; ID_BYTE_SIZE];
    /// When a new blob is being registered, the following object is sent.
    pub struct Blob {
        pub id: BlobId,
        pub blob: Vec<u8>,
        pub author: did::Did,
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for Blob {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                __codec_dest_edqy.push(&self.id);
                __codec_dest_edqy.push(&self.blob);
                __codec_dest_edqy.push(&self.author);
            }
        }
        impl _parity_scale_codec::EncodeLike for Blob {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for Blob {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(Blob {
                    id: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Blob.id".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    blob: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Blob.blob".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    author: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Blob.author".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Blob {
        #[inline]
        fn clone(&self) -> Blob {
            match *self {
                Blob {
                    id: ref __self_0_0,
                    blob: ref __self_0_1,
                    author: ref __self_0_2,
                } => Blob {
                    id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    blob: ::core::clone::Clone::clone(&(*__self_0_1)),
                    author: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Blob {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Blob {
        #[inline]
        fn eq(&self, other: &Blob) -> bool {
            match *other {
                Blob {
                    id: ref __self_1_0,
                    blob: ref __self_1_1,
                    author: ref __self_1_2,
                } => match *self {
                    Blob {
                        id: ref __self_0_0,
                        blob: ref __self_0_1,
                        author: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Blob) -> bool {
            match *other {
                Blob {
                    id: ref __self_1_0,
                    blob: ref __self_1_1,
                    author: ref __self_1_2,
                } => match *self {
                    Blob {
                        id: ref __self_0_0,
                        blob: ref __self_0_1,
                        author: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Blob {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Blob {
                    id: ref __self_0_0,
                    blob: ref __self_0_1,
                    author: ref __self_0_2,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Blob");
                    let _ = debug_trait_builder.field("id", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("blob", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("author", &&(*__self_0_2));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Blob {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Blob",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "blob",
                    &self.blob,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "author",
                    &self.author,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Blob {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "blob" => _serde::__private::Ok(__Field::__field1),
                            "author" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"blob" => _serde::__private::Ok(__Field::__field1),
                            b"author" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Blob>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Blob;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Blob")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<BlobId>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Blob with 3 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<Vec<u8>>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Blob with 3 elements",
                                ));
                            }
                        };
                        let __field2 =
                            match match _serde::de::SeqAccess::next_element::<did::Did>(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Blob with 3 elements",
                                        ),
                                    );
                                }
                            };
                        _serde::__private::Ok(Blob {
                            id: __field0,
                            blob: __field1,
                            author: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<BlobId> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<u8>> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<did::Did> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<BlobId>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "blob",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<u8>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "author",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<did::Did>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("blob") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("author") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Blob {
                            id: __field0,
                            blob: __field1,
                            author: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["id", "blob", "author"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Blob",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Blob>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub trait Trait: system::Config + did::Trait {
        /// Blobs larger than this will not be accepted.
        type MaxBlobSize: Get<u32>;
    }
    /// Error for the blob module.
    pub enum BlobError<T: Trait> {
        #[doc(hidden)]
        __Ignore(
            ::frame_support::sp_std::marker::PhantomData<(T,)>,
            ::frame_support::Never,
        ),
        /// The blob is greater than `MaxBlobSize`
        BlobTooBig,
        /// There is already a blob with same id
        BlobAlreadyExists,
        /// There is no such DID registered
        DidDoesNotExist,
        /// Signature verification failed while adding blob
        InvalidSig,
    }
    impl<T: Trait> ::frame_support::sp_std::fmt::Debug for BlobError<T> {
        fn fmt(
            &self,
            f: &mut ::frame_support::sp_std::fmt::Formatter<'_>,
        ) -> ::frame_support::sp_std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl<T: Trait> BlobError<T> {
        fn as_u8(&self) -> u8 {
            match self {
                BlobError::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"`__Ignore` can never be constructed",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                BlobError::BlobTooBig => 0,
                BlobError::BlobAlreadyExists => 0 + 1,
                BlobError::DidDoesNotExist => 0 + 1 + 1,
                BlobError::InvalidSig => 0 + 1 + 1 + 1,
            }
        }
        fn as_str(&self) -> &'static str {
            match self {
                Self::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"`__Ignore` can never be constructed",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                BlobError::BlobTooBig => "BlobTooBig",
                BlobError::BlobAlreadyExists => "BlobAlreadyExists",
                BlobError::DidDoesNotExist => "DidDoesNotExist",
                BlobError::InvalidSig => "InvalidSig",
            }
        }
    }
    impl<T: Trait> From<BlobError<T>> for &'static str {
        fn from(err: BlobError<T>) -> &'static str {
            err.as_str()
        }
    }
    impl<T: Trait> From<BlobError<T>> for ::frame_support::sp_runtime::DispatchError {
        fn from(err: BlobError<T>) -> Self {
            let index = <T::PalletInfo as ::frame_support::traits::PalletInfo>::index::<Module<T>>()
                .expect("Every active module has an index in the runtime; qed")
                as u8;
            ::frame_support::sp_runtime::DispatchError::Module {
                index,
                error: err.as_u8(),
                message: Some(err.as_str()),
            }
        }
    }
    impl<T: Trait> ::frame_support::error::ModuleErrorMetadata for BlobError<T> {
        fn metadata() -> &'static [::frame_support::error::ErrorMetadata] {
            &[
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("BlobTooBig"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" The blob is greater than `MaxBlobSize`",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("BlobAlreadyExists"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" There is already a blob with same id",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("DidDoesNotExist"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" There is no such DID registered",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("InvalidSig"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" Signature verification failed while adding blob",
                    ]),
                },
            ]
        }
    }
    use self::sp_api_hidden_includes_decl_storage::hidden_include::{
        StorageValue as _, StorageMap as _, StorageDoubleMap as _, StoragePrefixedMap as _,
        IterableStorageMap as _, IterableStorageDoubleMap as _,
    };
    #[doc(hidden)]
    mod sp_api_hidden_includes_decl_storage {
        pub extern crate frame_support as hidden_include;
    }
    trait Store {
        type Blobs;
    }
    impl<T: Trait + 'static> Store for Module<T> {
        type Blobs = Blobs;
    }
    impl<T: Trait + 'static> Module<T> {
        pub fn get_blob<
            K: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<
                dock::blob::BlobId,
            >,
        >(
            key: K,
        ) -> Option<(dock::did::Did, Vec<u8>)> {
            < Blobs < > as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: storage :: StorageMap < dock :: blob :: BlobId , (dock :: did :: Did , Vec < u8 >) > > :: get (key)
        }
    }
    #[doc(hidden)]
    pub struct __GetByteStructBlobs<T>(
        pub  self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<
            (T),
        >,
    );
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_Blobs:
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<
            self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>,
        > =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl<T: Trait> self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
        for __GetByteStructBlobs<T>
    {
        fn default_byte(
            &self,
        ) -> self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>
        {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_Blobs
                .get_or_init(|| {
                    let def_val: Option<(dock::did::Did, Vec<u8>)> = Default::default();
                    <Option<(dock::did::Did, Vec<u8>)> as Encode>::encode(&def_val)
                })
                .clone()
        }
    }
    unsafe impl<T: Trait> Send for __GetByteStructBlobs<T> {}
    unsafe impl<T: Trait> Sync for __GetByteStructBlobs<T> {}
    impl<T: Trait + 'static> Module<T> {
        #[doc(hidden)]
        pub fn storage_metadata(
        ) -> self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageMetadata
        {
            self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageMetadata { prefix : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("Blob") , entries : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (& [self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryMetadata { name : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("Blobs") , modifier : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryModifier :: Optional , ty : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryType :: Map { hasher : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageHasher :: Blake2_128Concat , key : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("dock::blob::BlobId") , value : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("(dock::did::Did, Vec<u8>)") , unused : false , } , default : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DefaultByteGetter (& __GetByteStructBlobs :: < T > (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_std :: marker :: PhantomData))) , documentation : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (& []) , }] [..]) , }
        }
    }
    /// Hidden instance generated to be internally used when module is used without
    /// instance.
    #[doc(hidden)]
    pub struct __InherentHiddenInstance;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for __InherentHiddenInstance {
        #[inline]
        fn clone(&self) -> __InherentHiddenInstance {
            match *self {
                __InherentHiddenInstance => __InherentHiddenInstance,
            }
        }
    }
    impl ::core::marker::StructuralEq for __InherentHiddenInstance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for __InherentHiddenInstance {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    impl ::core::marker::StructuralPartialEq for __InherentHiddenInstance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for __InherentHiddenInstance {
        #[inline]
        fn eq(&self, other: &__InherentHiddenInstance) -> bool {
            match *other {
                __InherentHiddenInstance => match *self {
                    __InherentHiddenInstance => true,
                },
            }
        }
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for __InherentHiddenInstance {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
            }
        }
        impl _parity_scale_codec::EncodeLike for __InherentHiddenInstance {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for __InherentHiddenInstance {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(__InherentHiddenInstance)
            }
        }
    };
    impl core::fmt::Debug for __InherentHiddenInstance {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("__InherentHiddenInstance").finish()
        }
    }
    impl self::sp_api_hidden_includes_decl_storage::hidden_include::traits::Instance
        for __InherentHiddenInstance
    {
        const PREFIX: &'static str = "Blob";
    }
    struct Blobs(
        self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<()>,
    );
    impl
        self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StoragePrefixedMap<(
            dock::did::Did,
            Vec<u8>,
        )> for Blobs
    {
        fn module_prefix() -> &'static [u8] {
            < __InherentHiddenInstance as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > :: PREFIX . as_bytes ()
        }
        fn storage_prefix() -> &'static [u8] {
            b"Blobs"
        }
    }
    impl
        self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<
            dock::blob::BlobId,
            (dock::did::Did, Vec<u8>),
        > for Blobs
    {
        type Query = Option<(dock::did::Did, Vec<u8>)>;
        type Hasher = self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_128Concat;
        fn module_prefix() -> &'static [u8] {
            < __InherentHiddenInstance as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > :: PREFIX . as_bytes ()
        }
        fn storage_prefix() -> &'static [u8] {
            b"Blobs"
        }
        fn from_optional_value_to_query(v: Option<(dock::did::Did, Vec<u8>)>) -> Self::Query {
            v.or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query) -> Option<(dock::did::Did, Vec<u8>)> {
            v
        }
    }
    pub struct Module<T: Trait>(::frame_support::sp_std::marker::PhantomData<(T,)>);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::clone::Clone + Trait> ::core::clone::Clone for Module<T> {
        #[inline]
        fn clone(&self) -> Module<T> {
            match *self {
                Module(ref __self_0_0) => Module(::core::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::marker::Copy + Trait> ::core::marker::Copy for Module<T> {}
    impl<T: Trait> ::core::marker::StructuralPartialEq for Module<T> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::cmp::PartialEq + Trait> ::core::cmp::PartialEq for Module<T> {
        #[inline]
        fn eq(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) => match *self {
                    Module(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) => match *self {
                    Module(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl<T: Trait> ::core::marker::StructuralEq for Module<T> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::cmp::Eq + Trait> ::core::cmp::Eq for Module<T> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<
                    ::frame_support::sp_std::marker::PhantomData<(T,)>,
                >;
            }
        }
    }
    impl<T: Trait> core::fmt::Debug for Module<T>
    where
        T: core::fmt::Debug,
    {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("Module").field(&self.0).finish()
        }
    }
    impl<T: frame_system::Config + Trait>
        ::frame_support::traits::OnInitialize<<T as frame_system::Config>::BlockNumber>
        for Module<T>
    {
    }
    impl<T: Trait> ::frame_support::traits::OnRuntimeUpgrade for Module<T> {
        fn on_runtime_upgrade() -> ::frame_support::dispatch::Weight {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "on_runtime_upgrade",
                            "core_mods::blob",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/blob.rs"),
                            Some(54u32),
                            Some("core_mods::blob"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
            .put_into_storage::<<T as frame_system::Config>::PalletInfo, Self>();
            <<T as frame_system::Config>::DbWeight as ::frame_support::traits::Get<_>>::get()
                .writes(1)
        }
    }
    impl<T: frame_system::Config + Trait>
        ::frame_support::traits::OnFinalize<<T as frame_system::Config>::BlockNumber>
        for Module<T>
    {
    }
    impl<T: frame_system::Config + Trait>
        ::frame_support::traits::OffchainWorker<<T as frame_system::Config>::BlockNumber>
        for Module<T>
    {
    }
    #[cfg(feature = "std")]
    impl<T: Trait> ::frame_support::traits::IntegrityTest for Module<T> {}
    /// Can also be called using [`Call`].
    ///
    /// [`Call`]: enum.Call.html
    impl<T: Trait> Module<T> {
        /// Create a new immutable blob.
        ///
        /// NOTE: Calling this function will bypass origin filters.
        pub fn new(
            origin: T::Origin,
            blob: dock::blob::Blob,
            signature: dock::did::DidSignature,
        ) -> DispatchResult {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "new",
                            "core_mods::blob",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/blob.rs"),
                            Some(54u32),
                            Some("core_mods::blob"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            Module::<T>::new_(origin, blob, signature)
        }
    }
    /// Dispatchable calls.
    ///
    /// Each variant of this enum maps to a dispatchable function from the associated module.
    pub enum Call<T: Trait> {
        #[doc(hidden)]
        #[codec(skip)]
        __PhantomItem(
            ::frame_support::sp_std::marker::PhantomData<(T,)>,
            ::frame_support::Never,
        ),
        #[allow(non_camel_case_types)]
        /// Create a new immutable blob.
        new(dock::blob::Blob, dock::did::DidSignature),
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl<T: Trait> _parity_scale_codec::Encode for Call<T> {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    Call::new(ref aa, ref ba) => {
                        __codec_dest_edqy.push_byte(0usize as u8);
                        __codec_dest_edqy.push(aa);
                        __codec_dest_edqy.push(ba);
                    }
                    _ => (),
                }
            }
        }
        impl<T: Trait> _parity_scale_codec::EncodeLike for Call<T> {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl<T: Trait> _parity_scale_codec::Decode for Call<T> {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                match __codec_input_edqy.read_byte()? {
                    __codec_x_edqy if __codec_x_edqy == 0usize as u8 => Ok(Call::new(
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => return Err("Error decoding field Call :: new.0".into()),
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => return Err("Error decoding field Call :: new.1".into()),
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    )),
                    _ => Err("No such variant in enum Call".into()),
                }
            }
        }
    };
    impl<T: Trait> ::frame_support::dispatch::GetDispatchInfo for Call<T> {
        fn get_dispatch_info(&self) -> ::frame_support::dispatch::DispatchInfo {
            match *self {
                Call::new(ref blob, ref signature) => {
                    let base_weight = T::DbWeight::get().reads_writes(2, 1)
                        + signature.weight()
                        + (1_100 * blob.blob.len()) as Weight;
                    let weight =
                        <dyn ::frame_support::dispatch::WeighData<(
                            &dock::blob::Blob,
                            &dock::did::DidSignature,
                        )>>::weigh_data(&base_weight, (blob, signature));
                    let class = <dyn ::frame_support::dispatch::ClassifyDispatch<(
                        &dock::blob::Blob,
                        &dock::did::DidSignature,
                    )>>::classify_dispatch(
                        &base_weight, (blob, signature)
                    );
                    let pays_fee =
                        <dyn ::frame_support::dispatch::PaysFee<(
                            &dock::blob::Blob,
                            &dock::did::DidSignature,
                        )>>::pays_fee(&base_weight, (blob, signature));
                    ::frame_support::dispatch::DispatchInfo {
                        weight,
                        class,
                        pays_fee,
                    }
                }
                Call::__PhantomItem(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__PhantomItem should never be used.",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::GetCallName for Call<T> {
        fn get_call_name(&self) -> &'static str {
            match *self {
                Call::new(ref blob, ref signature) => {
                    let _ = (blob, signature);
                    "new"
                }
                Call::__PhantomItem(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__PhantomItem should never be used.",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
        fn get_call_names() -> &'static [&'static str] {
            &["new"]
        }
    }
    pub use ::frame_support::traits::GetPalletVersion as _;
    impl<T: Trait> ::frame_support::traits::GetPalletVersion for Module<T> {
        fn current_version() -> ::frame_support::traits::PalletVersion {
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
        }
        fn storage_version() -> Option<::frame_support::traits::PalletVersion> {
            let key = ::frame_support::traits::PalletVersion::storage_key::<
                <T as frame_system::Config>::PalletInfo,
                Self,
            >()
            .expect("Every active pallet has a name in the runtime; qed");
            ::frame_support::storage::unhashed::get(&key)
        }
    }
    impl<T: Trait> ::frame_support::traits::OnGenesis for Module<T> {
        fn on_genesis() {
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
            .put_into_storage::<<T as frame_system::Config>::PalletInfo, Self>();
        }
    }
    impl<T: Trait> ::frame_support::dispatch::Clone for Call<T> {
        fn clone(&self) -> Self {
            match *self {
                Call::new(ref blob, ref signature) => {
                    Call::new((*blob).clone(), (*signature).clone())
                }
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::PartialEq for Call<T> {
        fn eq(&self, _other: &Self) -> bool {
            match *self {
                Call::new(ref blob, ref signature) => {
                    let self_params = (blob, signature);
                    if let Call::new(ref blob, ref signature) = *_other {
                        self_params == (blob, signature)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                ::core::panicking::panic("internal error: entered unreachable code")
                            }
                            _ => false,
                        }
                    }
                }
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::Eq for Call<T> {}
    impl<T: Trait> ::frame_support::dispatch::fmt::Debug for Call<T> {
        fn fmt(
            &self,
            _f: &mut ::frame_support::dispatch::fmt::Formatter,
        ) -> ::frame_support::dispatch::result::Result<(), ::frame_support::dispatch::fmt::Error>
        {
            match *self {
                Call::new(ref blob, ref signature) => _f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", ""],
                    &match (&"new", &(blob.clone(), signature.clone())) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                        ],
                    },
                )),
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
    }
    impl<T: Trait> ::frame_support::traits::UnfilteredDispatchable for Call<T> {
        type Origin = T::Origin;
        fn dispatch_bypass_filter(
            self,
            _origin: Self::Origin,
        ) -> ::frame_support::dispatch::DispatchResultWithPostInfo {
            match self {
                Call::new(blob, signature) => <Module<T>>::new(_origin, blob, signature)
                    .map(Into::into)
                    .map_err(Into::into),
                Call::__PhantomItem(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__PhantomItem should never be used.",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::Callable<T> for Module<T> {
        type Call = Call<T>;
    }
    impl<T: Trait> Module<T> {
        #[doc(hidden)]
        #[allow(dead_code)]
        pub fn call_functions() -> &'static [::frame_support::dispatch::FunctionMetadata] {
            &[::frame_support::dispatch::FunctionMetadata {
                name: ::frame_support::dispatch::DecodeDifferent::Encode("new"),
                arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                    ::frame_support::dispatch::FunctionArgumentMetadata {
                        name: ::frame_support::dispatch::DecodeDifferent::Encode("blob"),
                        ty: ::frame_support::dispatch::DecodeDifferent::Encode("dock::blob::Blob"),
                    },
                    ::frame_support::dispatch::FunctionArgumentMetadata {
                        name: ::frame_support::dispatch::DecodeDifferent::Encode("signature"),
                        ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                            "dock::did::DidSignature",
                        ),
                    },
                ]),
                documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                    r" Create a new immutable blob.",
                ]),
            }]
        }
    }
    impl<T: 'static + Trait> Module<T> {
        #[doc(hidden)]
        #[allow(dead_code)]
        pub fn module_constants_metadata(
        ) -> &'static [::frame_support::dispatch::ModuleConstantMetadata] {
            &[]
        }
    }
    impl<T: Trait> ::frame_support::dispatch::ModuleErrorMetadata for Module<T> {
        fn metadata() -> &'static [::frame_support::dispatch::ErrorMetadata] {
            <&'static str as ::frame_support::dispatch::ModuleErrorMetadata>::metadata()
        }
    }
    impl<T: Trait> Module<T> {
        fn new_(
            origin: <T as system::Config>::Origin,
            blob: Blob,
            signature: did::DidSignature,
        ) -> DispatchResult {
            ensure_signed(origin)?;
            {
                if !(T::MaxBlobSize::get() as usize >= blob.blob.len()) {
                    {
                        return Err(BlobError::<T>::BlobTooBig.into());
                    };
                }
            };
            {
                if !!Blobs::contains_key(&blob.id) {
                    {
                        return Err(BlobError::<T>::BlobAlreadyExists.into());
                    };
                }
            };
            let payload = crate::StateChange::Blob(blob.clone()).encode();
            let valid = did::Module::<T>::verify_sig_from_did(&signature, &payload, &blob.author)?;
            {
                if !valid {
                    {
                        return Err(BlobError::<T>::InvalidSig.into());
                    };
                }
            };
            Blobs::insert(blob.id, (blob.author, blob.blob));
            Ok(())
        }
    }
}
pub mod did {
    use super::{BlockNumber, StateChange};
    use crate as dock;
    use codec::{Decode, Encode};
    use frame_support::{
        decl_error, decl_event, decl_module, decl_storage, dispatch::DispatchError,
        dispatch::DispatchResult, ensure, fail, traits::Get, weights::Weight,
    };
    use frame_system::{self as system, ensure_signed};
    use sp_core::{ecdsa, ed25519, sr25519};
    use sp_runtime::traits::Verify;
    use sp_std::convert::TryFrom;
    use sp_std::fmt;
    /// Size of the Dock DID in bytes
    pub const DID_BYTE_SIZE: usize = 32;
    /// The type of the Dock DID
    pub type Did = [u8; DID_BYTE_SIZE];
    /// The module's configuration trait.
    pub trait Trait: system::Config {
        /// The overarching event type.
        type Event: From<Event> + Into<<Self as system::Config>::Event>;
    }
    /// Error for the DID module.
    pub enum Error<T: Trait> {
        #[doc(hidden)]
        __Ignore(
            ::frame_support::sp_std::marker::PhantomData<(T,)>,
            ::frame_support::Never,
        ),
        /// Given public key is not of the correct size
        PublicKeySizeIncorrect,
        /// There is already a DID with same value
        DidAlreadyExists,
        /// There is no such DID registered
        DidDoesNotExist,
        /// For replay protection, an update to state is required to contain the same block number
        /// in which the last update was performed.
        DifferentBlockNumber,
        /// Signature type does not match public key type
        InvalidSigType,
        /// Signature verification failed while key update or did removal
        InvalidSig,
    }
    impl<T: Trait> ::frame_support::sp_std::fmt::Debug for Error<T> {
        fn fmt(
            &self,
            f: &mut ::frame_support::sp_std::fmt::Formatter<'_>,
        ) -> ::frame_support::sp_std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl<T: Trait> Error<T> {
        fn as_u8(&self) -> u8 {
            match self {
                Error::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"`__Ignore` can never be constructed",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Error::PublicKeySizeIncorrect => 0,
                Error::DidAlreadyExists => 0 + 1,
                Error::DidDoesNotExist => 0 + 1 + 1,
                Error::DifferentBlockNumber => 0 + 1 + 1 + 1,
                Error::InvalidSigType => 0 + 1 + 1 + 1 + 1,
                Error::InvalidSig => 0 + 1 + 1 + 1 + 1 + 1,
            }
        }
        fn as_str(&self) -> &'static str {
            match self {
                Self::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"`__Ignore` can never be constructed",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Error::PublicKeySizeIncorrect => "PublicKeySizeIncorrect",
                Error::DidAlreadyExists => "DidAlreadyExists",
                Error::DidDoesNotExist => "DidDoesNotExist",
                Error::DifferentBlockNumber => "DifferentBlockNumber",
                Error::InvalidSigType => "InvalidSigType",
                Error::InvalidSig => "InvalidSig",
            }
        }
    }
    impl<T: Trait> From<Error<T>> for &'static str {
        fn from(err: Error<T>) -> &'static str {
            err.as_str()
        }
    }
    impl<T: Trait> From<Error<T>> for ::frame_support::sp_runtime::DispatchError {
        fn from(err: Error<T>) -> Self {
            let index = <T::PalletInfo as ::frame_support::traits::PalletInfo>::index::<Module<T>>()
                .expect("Every active module has an index in the runtime; qed")
                as u8;
            ::frame_support::sp_runtime::DispatchError::Module {
                index,
                error: err.as_u8(),
                message: Some(err.as_str()),
            }
        }
    }
    impl<T: Trait> ::frame_support::error::ModuleErrorMetadata for Error<T> {
        fn metadata() -> &'static [::frame_support::error::ErrorMetadata] {
            &[
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("PublicKeySizeIncorrect"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" Given public key is not of the correct size",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("DidAlreadyExists"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" There is already a DID with same value",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("DidDoesNotExist"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" There is no such DID registered",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("DifferentBlockNumber"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" For replay protection, an update to state is required to contain the same block number",
                        r" in which the last update was performed.",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("InvalidSigType"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" Signature type does not match public key type",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("InvalidSig"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" Signature verification failed while key update or did removal",
                    ]),
                },
            ]
        }
    }
    /// A wrapper over 32-byte array
    pub struct Bytes32 {
        pub value: [u8; 32],
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for Bytes32 {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                _parity_scale_codec::Encode::encode_to(&&self.value, __codec_dest_edqy)
            }
            fn encode(&self) -> _parity_scale_codec::alloc::vec::Vec<u8> {
                _parity_scale_codec::Encode::encode(&&self.value)
            }
            fn using_encoded<R, F: FnOnce(&[u8]) -> R>(&self, f: F) -> R {
                _parity_scale_codec::Encode::using_encoded(&&self.value, f)
            }
        }
        impl _parity_scale_codec::EncodeLike for Bytes32 {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for Bytes32 {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(Bytes32 {
                    value: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Bytes32.value".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Bytes32 {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Bytes32 {
                    value: ref __self_0_0,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Bytes32");
                    let _ = debug_trait_builder.field("value", &&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Bytes32 {
        #[inline]
        fn clone(&self) -> Bytes32 {
            match *self {
                Bytes32 {
                    value: ref __self_0_0,
                } => Bytes32 {
                    value: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Bytes32 {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Bytes32 {
        #[inline]
        fn eq(&self, other: &Bytes32) -> bool {
            match *other {
                Bytes32 {
                    value: ref __self_1_0,
                } => match *self {
                    Bytes32 {
                        value: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Bytes32) -> bool {
            match *other {
                Bytes32 {
                    value: ref __self_1_0,
                } => match *self {
                    Bytes32 {
                        value: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ::core::marker::StructuralEq for Bytes32 {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Bytes32 {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<[u8; 32]>;
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Bytes32 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Bytes32",
                    false as usize + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "value",
                    &self.value,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Bytes32 {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "value" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"value" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Bytes32>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Bytes32;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Bytes32")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<[u8; 32]>(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Bytes32 with 1 element",
                                        ),
                                    );
                                }
                            };
                        _serde::__private::Ok(Bytes32 { value: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<[u8; 32]> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "value",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<[u8; 32]>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("value") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Bytes32 { value: __field0 })
                    }
                }
                const FIELDS: &'static [&'static str] = &["value"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Bytes32",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Bytes32>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl Bytes32 {
        pub fn as_bytes(&self) -> &[u8] {
            &self.value
        }
    }
    pub trait BigArray<'de>: Sized {
        fn serialize<S>(
            &self,
            serializer: S,
        ) -> ::serde_big_array::reex::result::Result<S::Ok, S::Error>
        where
            S: ::serde_big_array::reex::Serializer;
        fn deserialize<D>(
            deserializer: D,
        ) -> ::serde_big_array::reex::result::Result<Self, D::Error>
        where
            D: ::serde_big_array::reex::Deserializer<'de>;
    }
    impl<'de, T> BigArray<'de> for [T; 33]
    where
        T: Default
            + Copy
            + ::serde_big_array::reex::Serialize
            + ::serde_big_array::reex::Deserialize<'de>,
    {
        fn serialize<S>(
            &self,
            serializer: S,
        ) -> ::serde_big_array::reex::result::Result<S::Ok, S::Error>
        where
            S: ::serde_big_array::reex::Serializer,
        {
            use ::serde_big_array::reex::ser::SerializeTuple;
            let mut seq = serializer.serialize_tuple(self.len())?;
            for elem in &self[..] {
                seq.serialize_element(elem)?;
            }
            seq.end()
        }
        fn deserialize<D>(
            deserializer: D,
        ) -> ::serde_big_array::reex::result::Result<[T; 33], D::Error>
        where
            D: ::serde_big_array::reex::Deserializer<'de>,
        {
            use ::serde_big_array::reex::PhantomData;
            struct ArrayVisitor<T> {
                element: PhantomData<T>,
            }
            impl<'de, T> ::serde_big_array::reex::Visitor<'de> for ArrayVisitor<T>
            where
                T: Default + Copy + ::serde_big_array::reex::Deserialize<'de>,
            {
                type Value = [T; 33];
                fn expecting(
                    &self,
                    formatter: &mut ::serde_big_array::reex::fmt::Formatter,
                ) -> ::serde_big_array::reex::fmt::Result {
                    formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["an array of length 33"],
                        &match () {
                            () => [],
                        },
                    ))
                }
                fn visit_seq<A>(
                    self,
                    mut seq: A,
                ) -> ::serde_big_array::reex::result::Result<[T; 33], A::Error>
                where
                    A: ::serde_big_array::reex::SeqAccess<'de>,
                {
                    let mut arr = [T::default(); 33];
                    for i in 0..33 {
                        arr[i] = seq.next_element()?.ok_or_else(|| {
                            ::serde_big_array::reex::Error::invalid_length(i, &self)
                        })?;
                    }
                    Ok(arr)
                }
            }
            let visitor = ArrayVisitor {
                element: PhantomData,
            };
            #[allow(unused_parens)]
            deserializer.deserialize_tuple(33, visitor)
        }
    }
    impl<'de, T> BigArray<'de> for [T; 64]
    where
        T: Default
            + Copy
            + ::serde_big_array::reex::Serialize
            + ::serde_big_array::reex::Deserialize<'de>,
    {
        fn serialize<S>(
            &self,
            serializer: S,
        ) -> ::serde_big_array::reex::result::Result<S::Ok, S::Error>
        where
            S: ::serde_big_array::reex::Serializer,
        {
            use ::serde_big_array::reex::ser::SerializeTuple;
            let mut seq = serializer.serialize_tuple(self.len())?;
            for elem in &self[..] {
                seq.serialize_element(elem)?;
            }
            seq.end()
        }
        fn deserialize<D>(
            deserializer: D,
        ) -> ::serde_big_array::reex::result::Result<[T; 64], D::Error>
        where
            D: ::serde_big_array::reex::Deserializer<'de>,
        {
            use ::serde_big_array::reex::PhantomData;
            struct ArrayVisitor<T> {
                element: PhantomData<T>,
            }
            impl<'de, T> ::serde_big_array::reex::Visitor<'de> for ArrayVisitor<T>
            where
                T: Default + Copy + ::serde_big_array::reex::Deserialize<'de>,
            {
                type Value = [T; 64];
                fn expecting(
                    &self,
                    formatter: &mut ::serde_big_array::reex::fmt::Formatter,
                ) -> ::serde_big_array::reex::fmt::Result {
                    formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["an array of length 64"],
                        &match () {
                            () => [],
                        },
                    ))
                }
                fn visit_seq<A>(
                    self,
                    mut seq: A,
                ) -> ::serde_big_array::reex::result::Result<[T; 64], A::Error>
                where
                    A: ::serde_big_array::reex::SeqAccess<'de>,
                {
                    let mut arr = [T::default(); 64];
                    for i in 0..64 {
                        arr[i] = seq.next_element()?.ok_or_else(|| {
                            ::serde_big_array::reex::Error::invalid_length(i, &self)
                        })?;
                    }
                    Ok(arr)
                }
            }
            let visitor = ArrayVisitor {
                element: PhantomData,
            };
            #[allow(unused_parens)]
            deserializer.deserialize_tuple(64, visitor)
        }
    }
    impl<'de, T> BigArray<'de> for [T; 65]
    where
        T: Default
            + Copy
            + ::serde_big_array::reex::Serialize
            + ::serde_big_array::reex::Deserialize<'de>,
    {
        fn serialize<S>(
            &self,
            serializer: S,
        ) -> ::serde_big_array::reex::result::Result<S::Ok, S::Error>
        where
            S: ::serde_big_array::reex::Serializer,
        {
            use ::serde_big_array::reex::ser::SerializeTuple;
            let mut seq = serializer.serialize_tuple(self.len())?;
            for elem in &self[..] {
                seq.serialize_element(elem)?;
            }
            seq.end()
        }
        fn deserialize<D>(
            deserializer: D,
        ) -> ::serde_big_array::reex::result::Result<[T; 65], D::Error>
        where
            D: ::serde_big_array::reex::Deserializer<'de>,
        {
            use ::serde_big_array::reex::PhantomData;
            struct ArrayVisitor<T> {
                element: PhantomData<T>,
            }
            impl<'de, T> ::serde_big_array::reex::Visitor<'de> for ArrayVisitor<T>
            where
                T: Default + Copy + ::serde_big_array::reex::Deserialize<'de>,
            {
                type Value = [T; 65];
                fn expecting(
                    &self,
                    formatter: &mut ::serde_big_array::reex::fmt::Formatter,
                ) -> ::serde_big_array::reex::fmt::Result {
                    formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["an array of length 65"],
                        &match () {
                            () => [],
                        },
                    ))
                }
                fn visit_seq<A>(
                    self,
                    mut seq: A,
                ) -> ::serde_big_array::reex::result::Result<[T; 65], A::Error>
                where
                    A: ::serde_big_array::reex::SeqAccess<'de>,
                {
                    let mut arr = [T::default(); 65];
                    for i in 0..65 {
                        arr[i] = seq.next_element()?.ok_or_else(|| {
                            ::serde_big_array::reex::Error::invalid_length(i, &self)
                        })?;
                    }
                    Ok(arr)
                }
            }
            let visitor = ArrayVisitor {
                element: PhantomData,
            };
            #[allow(unused_parens)]
            deserializer.deserialize_tuple(65, visitor)
        }
    }
    /// A wrapper over a byte array
    pub struct Bytes33 {
        #[serde(with = "BigArray")]
        pub value: [u8; 33],
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for Bytes33 {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                _parity_scale_codec::Encode::encode_to(&&self.value, __codec_dest_edqy)
            }
            fn encode(&self) -> _parity_scale_codec::alloc::vec::Vec<u8> {
                _parity_scale_codec::Encode::encode(&&self.value)
            }
            fn using_encoded<R, F: FnOnce(&[u8]) -> R>(&self, f: F) -> R {
                _parity_scale_codec::Encode::using_encoded(&&self.value, f)
            }
        }
        impl _parity_scale_codec::EncodeLike for Bytes33 {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for Bytes33 {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(Bytes33 {
                    value: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Bytes33.value".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Bytes33 {
        #[inline]
        fn clone(&self) -> Bytes33 {
            match *self {
                Bytes33 {
                    value: ref __self_0_0,
                } => Bytes33 {
                    value: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Bytes33 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Bytes33",
                    false as usize + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "value", {
                    struct __SerializeWith<'__a> {
                        values: (&'__a [u8; 33],),
                        phantom: _serde::__private::PhantomData<Bytes33>,
                    }
                    impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                        fn serialize<__S>(
                            &self,
                            __s: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            BigArray::serialize(self.values.0, __s)
                        }
                    }
                    &__SerializeWith {
                        values: (&self.value,),
                        phantom: _serde::__private::PhantomData::<Bytes33>,
                    }
                }) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Bytes33 {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "value" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"value" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Bytes33>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Bytes33;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Bytes33")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match {
                            struct __DeserializeWith<'de> {
                                value: [u8; 33],
                                phantom: _serde::__private::PhantomData<Bytes33>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: match BigArray::deserialize(__deserializer) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                match _serde::de::SeqAccess::next_element::<__DeserializeWith<'de>>(
                                    &mut __seq,
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                },
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Bytes33 with 1 element",
                                ));
                            }
                        };
                        _serde::__private::Ok(Bytes33 { value: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<[u8; 33]> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "value",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some({
                                        struct __DeserializeWith<'de> {
                                            value: [u8; 33],
                                            phantom: _serde::__private::PhantomData<Bytes33>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: match BigArray::deserialize(
                                                        __deserializer,
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    },
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field("value"),
                                )
                            }
                        };
                        _serde::__private::Ok(Bytes33 { value: __field0 })
                    }
                }
                const FIELDS: &'static [&'static str] = &["value"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Bytes33",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Bytes33>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Implementing Default as it cannot be automatically derived for arrays of size > 32
    impl Default for Bytes33 {
        fn default() -> Self {
            Self { value: [0; 33] }
        }
    }
    /// Implementing Debug as it cannot be automatically derived for arrays of size > 32
    impl fmt::Debug for Bytes33 {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            self.value[..].fmt(f)
        }
    }
    /// Implementing PartialEq as it cannot be automatically derived for arrays of size > 32
    impl PartialEq for Bytes33 {
        fn eq(&self, other: &Self) -> bool {
            self.value[..] == other.value[..]
        }
    }
    impl Eq for Bytes33 {}
    impl Bytes33 {
        /// Return a slice to the underlying bytearray
        pub fn as_bytes(&self) -> &[u8] {
            &self.value
        }
    }
    /// A wrapper over a byte array
    pub struct Bytes64 {
        #[serde(with = "BigArray")]
        pub value: [u8; 64],
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for Bytes64 {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                _parity_scale_codec::Encode::encode_to(&&self.value, __codec_dest_edqy)
            }
            fn encode(&self) -> _parity_scale_codec::alloc::vec::Vec<u8> {
                _parity_scale_codec::Encode::encode(&&self.value)
            }
            fn using_encoded<R, F: FnOnce(&[u8]) -> R>(&self, f: F) -> R {
                _parity_scale_codec::Encode::using_encoded(&&self.value, f)
            }
        }
        impl _parity_scale_codec::EncodeLike for Bytes64 {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for Bytes64 {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(Bytes64 {
                    value: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Bytes64.value".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Bytes64 {
        #[inline]
        fn clone(&self) -> Bytes64 {
            match *self {
                Bytes64 {
                    value: ref __self_0_0,
                } => Bytes64 {
                    value: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Bytes64 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Bytes64",
                    false as usize + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "value", {
                    struct __SerializeWith<'__a> {
                        values: (&'__a [u8; 64],),
                        phantom: _serde::__private::PhantomData<Bytes64>,
                    }
                    impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                        fn serialize<__S>(
                            &self,
                            __s: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            BigArray::serialize(self.values.0, __s)
                        }
                    }
                    &__SerializeWith {
                        values: (&self.value,),
                        phantom: _serde::__private::PhantomData::<Bytes64>,
                    }
                }) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Bytes64 {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "value" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"value" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Bytes64>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Bytes64;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Bytes64")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match {
                            struct __DeserializeWith<'de> {
                                value: [u8; 64],
                                phantom: _serde::__private::PhantomData<Bytes64>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: match BigArray::deserialize(__deserializer) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                match _serde::de::SeqAccess::next_element::<__DeserializeWith<'de>>(
                                    &mut __seq,
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                },
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Bytes64 with 1 element",
                                ));
                            }
                        };
                        _serde::__private::Ok(Bytes64 { value: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<[u8; 64]> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "value",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some({
                                        struct __DeserializeWith<'de> {
                                            value: [u8; 64],
                                            phantom: _serde::__private::PhantomData<Bytes64>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: match BigArray::deserialize(
                                                        __deserializer,
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    },
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field("value"),
                                )
                            }
                        };
                        _serde::__private::Ok(Bytes64 { value: __field0 })
                    }
                }
                const FIELDS: &'static [&'static str] = &["value"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Bytes64",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Bytes64>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Implementing Default as it cannot be automatically derived for arrays of size > 32
    impl Default for Bytes64 {
        fn default() -> Self {
            Self { value: [0; 64] }
        }
    }
    /// Implementing Debug as it cannot be automatically derived for arrays of size > 32
    impl fmt::Debug for Bytes64 {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            self.value[..].fmt(f)
        }
    }
    /// Implementing PartialEq as it cannot be automatically derived for arrays of size > 32
    impl PartialEq for Bytes64 {
        fn eq(&self, other: &Self) -> bool {
            self.value[..] == other.value[..]
        }
    }
    impl Eq for Bytes64 {}
    impl Bytes64 {
        /// Return a slice to the underlying bytearray
        pub fn as_bytes(&self) -> &[u8] {
            &self.value
        }
    }
    /// A wrapper over a byte array
    pub struct Bytes65 {
        #[serde(with = "BigArray")]
        pub value: [u8; 65],
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for Bytes65 {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                _parity_scale_codec::Encode::encode_to(&&self.value, __codec_dest_edqy)
            }
            fn encode(&self) -> _parity_scale_codec::alloc::vec::Vec<u8> {
                _parity_scale_codec::Encode::encode(&&self.value)
            }
            fn using_encoded<R, F: FnOnce(&[u8]) -> R>(&self, f: F) -> R {
                _parity_scale_codec::Encode::using_encoded(&&self.value, f)
            }
        }
        impl _parity_scale_codec::EncodeLike for Bytes65 {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for Bytes65 {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(Bytes65 {
                    value: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Bytes65.value".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Bytes65 {
        #[inline]
        fn clone(&self) -> Bytes65 {
            match *self {
                Bytes65 {
                    value: ref __self_0_0,
                } => Bytes65 {
                    value: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Bytes65 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Bytes65",
                    false as usize + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(&mut __serde_state, "value", {
                    struct __SerializeWith<'__a> {
                        values: (&'__a [u8; 65],),
                        phantom: _serde::__private::PhantomData<Bytes65>,
                    }
                    impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                        fn serialize<__S>(
                            &self,
                            __s: __S,
                        ) -> _serde::__private::Result<__S::Ok, __S::Error>
                        where
                            __S: _serde::Serializer,
                        {
                            BigArray::serialize(self.values.0, __s)
                        }
                    }
                    &__SerializeWith {
                        values: (&self.value,),
                        phantom: _serde::__private::PhantomData::<Bytes65>,
                    }
                }) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Bytes65 {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "value" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"value" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Bytes65>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Bytes65;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Bytes65")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match {
                            struct __DeserializeWith<'de> {
                                value: [u8; 65],
                                phantom: _serde::__private::PhantomData<Bytes65>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: match BigArray::deserialize(__deserializer) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                match _serde::de::SeqAccess::next_element::<__DeserializeWith<'de>>(
                                    &mut __seq,
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                },
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Bytes65 with 1 element",
                                ));
                            }
                        };
                        _serde::__private::Ok(Bytes65 { value: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<[u8; 65]> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "value",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some({
                                        struct __DeserializeWith<'de> {
                                            value: [u8; 65],
                                            phantom: _serde::__private::PhantomData<Bytes65>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        impl<'de> _serde::Deserialize<'de> for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: match BigArray::deserialize(
                                                        __deserializer,
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    },
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    <__A::Error as _serde::de::Error>::missing_field("value"),
                                )
                            }
                        };
                        _serde::__private::Ok(Bytes65 { value: __field0 })
                    }
                }
                const FIELDS: &'static [&'static str] = &["value"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Bytes65",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Bytes65>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Implementing Default as it cannot be automatically derived for arrays of size > 32
    impl Default for Bytes65 {
        fn default() -> Self {
            Self { value: [0; 65] }
        }
    }
    /// Implementing Debug as it cannot be automatically derived for arrays of size > 32
    impl fmt::Debug for Bytes65 {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            self.value[..].fmt(f)
        }
    }
    /// Implementing PartialEq as it cannot be automatically derived for arrays of size > 32
    impl PartialEq for Bytes65 {
        fn eq(&self, other: &Self) -> bool {
            self.value[..] == other.value[..]
        }
    }
    impl Eq for Bytes65 {}
    impl Bytes65 {
        /// Return a slice to the underlying bytearray
        pub fn as_bytes(&self) -> &[u8] {
            &self.value
        }
    }
    /// An abstraction for a public key. Abstracts the type and value of the public key where the value is a
    /// byte array
    pub enum PublicKey {
        /// Public key for Sr25519 is 32 bytes
        Sr25519(Bytes32),
        /// Public key for Ed25519 is 32 bytes
        Ed25519(Bytes32),
        /// Compressed public key for Secp256k1 is 33 bytes
        Secp256k1(Bytes33),
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for PublicKey {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    PublicKey::Sr25519(ref aa) => {
                        __codec_dest_edqy.push_byte(0usize as u8);
                        __codec_dest_edqy.push(aa);
                    }
                    PublicKey::Ed25519(ref aa) => {
                        __codec_dest_edqy.push_byte(1usize as u8);
                        __codec_dest_edqy.push(aa);
                    }
                    PublicKey::Secp256k1(ref aa) => {
                        __codec_dest_edqy.push_byte(2usize as u8);
                        __codec_dest_edqy.push(aa);
                    }
                    _ => (),
                }
            }
        }
        impl _parity_scale_codec::EncodeLike for PublicKey {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for PublicKey {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                match __codec_input_edqy.read_byte()? {
                    __codec_x_edqy if __codec_x_edqy == 0usize as u8 => Ok(PublicKey::Sr25519({
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err("Error decoding field PublicKey :: Sr25519.0".into())
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    })),
                    __codec_x_edqy if __codec_x_edqy == 1usize as u8 => Ok(PublicKey::Ed25519({
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err("Error decoding field PublicKey :: Ed25519.0".into())
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    })),
                    __codec_x_edqy if __codec_x_edqy == 2usize as u8 => Ok(PublicKey::Secp256k1({
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err("Error decoding field PublicKey :: Secp256k1.0".into())
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    })),
                    _ => Err("No such variant in enum PublicKey".into()),
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for PublicKey {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&PublicKey::Sr25519(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Sr25519");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&PublicKey::Ed25519(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Ed25519");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&PublicKey::Secp256k1(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Secp256k1");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for PublicKey {
        #[inline]
        fn clone(&self) -> PublicKey {
            match (&*self,) {
                (&PublicKey::Sr25519(ref __self_0),) => {
                    PublicKey::Sr25519(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&PublicKey::Ed25519(ref __self_0),) => {
                    PublicKey::Ed25519(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&PublicKey::Secp256k1(ref __self_0),) => {
                    PublicKey::Secp256k1(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for PublicKey {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for PublicKey {
        #[inline]
        fn eq(&self, other: &PublicKey) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&PublicKey::Sr25519(ref __self_0), &PublicKey::Sr25519(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&PublicKey::Ed25519(ref __self_0), &PublicKey::Ed25519(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (
                            &PublicKey::Secp256k1(ref __self_0),
                            &PublicKey::Secp256k1(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &PublicKey) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&PublicKey::Sr25519(ref __self_0), &PublicKey::Sr25519(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&PublicKey::Ed25519(ref __self_0), &PublicKey::Ed25519(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (
                            &PublicKey::Secp256k1(ref __self_0),
                            &PublicKey::Secp256k1(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for PublicKey {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for PublicKey {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<Bytes32>;
                let _: ::core::cmp::AssertParamIsEq<Bytes32>;
                let _: ::core::cmp::AssertParamIsEq<Bytes33>;
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PublicKey {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    PublicKey::Sr25519(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "PublicKey",
                            0u32,
                            "Sr25519",
                            __field0,
                        )
                    }
                    PublicKey::Ed25519(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "PublicKey",
                            1u32,
                            "Ed25519",
                            __field0,
                        )
                    }
                    PublicKey::Secp256k1(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "PublicKey",
                            2u32,
                            "Secp256k1",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PublicKey {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Sr25519" => _serde::__private::Ok(__Field::__field0),
                            "Ed25519" => _serde::__private::Ok(__Field::__field1),
                            "Secp256k1" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Sr25519" => _serde::__private::Ok(__Field::__field0),
                            b"Ed25519" => _serde::__private::Ok(__Field::__field1),
                            b"Secp256k1" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PublicKey>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PublicKey;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum PublicKey")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Bytes32>(__variant),
                                PublicKey::Sr25519,
                            ),
                            (__Field::__field1, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Bytes32>(__variant),
                                PublicKey::Ed25519,
                            ),
                            (__Field::__field2, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Bytes33>(__variant),
                                PublicKey::Secp256k1,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Sr25519", "Ed25519", "Secp256k1"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "PublicKey",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<PublicKey>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// An abstraction for a signature.
    pub enum DidSignature {
        /// Signature for Sr25519 is 64 bytes
        Sr25519(Bytes64),
        /// Signature for Ed25519 is 64 bytes
        Ed25519(Bytes64),
        /// Signature for Secp256k1 is 65 bytes
        Secp256k1(Bytes65),
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for DidSignature {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    DidSignature::Sr25519(ref aa) => {
                        __codec_dest_edqy.push_byte(0usize as u8);
                        __codec_dest_edqy.push(aa);
                    }
                    DidSignature::Ed25519(ref aa) => {
                        __codec_dest_edqy.push_byte(1usize as u8);
                        __codec_dest_edqy.push(aa);
                    }
                    DidSignature::Secp256k1(ref aa) => {
                        __codec_dest_edqy.push_byte(2usize as u8);
                        __codec_dest_edqy.push(aa);
                    }
                    _ => (),
                }
            }
        }
        impl _parity_scale_codec::EncodeLike for DidSignature {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for DidSignature {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                match __codec_input_edqy.read_byte()? {
                    __codec_x_edqy if __codec_x_edqy == 0usize as u8 => {
                        Ok(DidSignature::Sr25519({
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err(
                                        "Error decoding field DidSignature :: Sr25519.0".into()
                                    )
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        }))
                    }
                    __codec_x_edqy if __codec_x_edqy == 1usize as u8 => {
                        Ok(DidSignature::Ed25519({
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err(
                                        "Error decoding field DidSignature :: Ed25519.0".into()
                                    )
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        }))
                    }
                    __codec_x_edqy if __codec_x_edqy == 2usize as u8 => {
                        Ok(DidSignature::Secp256k1({
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err(
                                        "Error decoding field DidSignature :: Secp256k1.0".into()
                                    )
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        }))
                    }
                    _ => Err("No such variant in enum DidSignature".into()),
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for DidSignature {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&DidSignature::Sr25519(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Sr25519");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&DidSignature::Ed25519(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Ed25519");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&DidSignature::Secp256k1(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Secp256k1");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for DidSignature {
        #[inline]
        fn clone(&self) -> DidSignature {
            match (&*self,) {
                (&DidSignature::Sr25519(ref __self_0),) => {
                    DidSignature::Sr25519(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&DidSignature::Ed25519(ref __self_0),) => {
                    DidSignature::Ed25519(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&DidSignature::Secp256k1(ref __self_0),) => {
                    DidSignature::Secp256k1(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for DidSignature {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for DidSignature {
        #[inline]
        fn eq(&self, other: &DidSignature) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &DidSignature::Sr25519(ref __self_0),
                            &DidSignature::Sr25519(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &DidSignature::Ed25519(ref __self_0),
                            &DidSignature::Ed25519(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &DidSignature::Secp256k1(ref __self_0),
                            &DidSignature::Secp256k1(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &DidSignature) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &DidSignature::Sr25519(ref __self_0),
                            &DidSignature::Sr25519(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &DidSignature::Ed25519(ref __self_0),
                            &DidSignature::Ed25519(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &DidSignature::Secp256k1(ref __self_0),
                            &DidSignature::Secp256k1(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for DidSignature {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for DidSignature {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<Bytes64>;
                let _: ::core::cmp::AssertParamIsEq<Bytes64>;
                let _: ::core::cmp::AssertParamIsEq<Bytes65>;
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DidSignature {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    DidSignature::Sr25519(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "DidSignature",
                            0u32,
                            "Sr25519",
                            __field0,
                        )
                    }
                    DidSignature::Ed25519(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "DidSignature",
                            1u32,
                            "Ed25519",
                            __field0,
                        )
                    }
                    DidSignature::Secp256k1(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "DidSignature",
                            2u32,
                            "Secp256k1",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DidSignature {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Sr25519" => _serde::__private::Ok(__Field::__field0),
                            "Ed25519" => _serde::__private::Ok(__Field::__field1),
                            "Secp256k1" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Sr25519" => _serde::__private::Ok(__Field::__field0),
                            b"Ed25519" => _serde::__private::Ok(__Field::__field1),
                            b"Secp256k1" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DidSignature>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DidSignature;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum DidSignature")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Bytes64>(__variant),
                                DidSignature::Sr25519,
                            ),
                            (__Field::__field1, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Bytes64>(__variant),
                                DidSignature::Ed25519,
                            ),
                            (__Field::__field2, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Bytes65>(__variant),
                                DidSignature::Secp256k1,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Sr25519", "Ed25519", "Secp256k1"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "DidSignature",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DidSignature>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub const SR25519_WEIGHT: Weight = 140_000_000;
    pub const ED25519_WEIGHT: Weight = 152_000_000;
    pub const SECP256K1_WEIGHT: Weight = 456_000_000;
    impl DidSignature {
        /// Try to get reference to the bytes if its a Sr25519 signature. Return error if its not.
        pub fn as_sr25519_sig_bytes(&self) -> Result<&[u8], ()> {
            match self {
                DidSignature::Sr25519(bytes) => Ok(bytes.as_bytes()),
                _ => Err(()),
            }
        }
        /// Try to get reference to the bytes if its a Ed25519 signature. Return error if its not.
        pub fn as_ed25519_sig_bytes(&self) -> Result<&[u8], ()> {
            match self {
                DidSignature::Ed25519(bytes) => Ok(bytes.as_bytes()),
                _ => Err(()),
            }
        }
        /// Try to get reference to the bytes if its a Secp256k1 signature. Return error if its not.
        pub fn as_secp256k1_sig_bytes(&self) -> Result<&[u8], ()> {
            match self {
                DidSignature::Secp256k1(bytes) => Ok(bytes.as_bytes()),
                _ => Err(()),
            }
        }
        /// Get weight for signature verification.
        /// Considers the type of signature. Disregards message size as messages are hashed giving the
        /// same output size and hashing itself is very cheap. The extrinsic using it might decide to
        /// consider adding some weight proportional to the message size.
        pub fn weight(&self) -> Weight {
            match self {
                DidSignature::Sr25519(_) => SR25519_WEIGHT,
                DidSignature::Ed25519(_) => ED25519_WEIGHT,
                DidSignature::Secp256k1(_) => SECP256K1_WEIGHT,
            }
        }
    }
    /// `controller` is the controller of the DID and its value might be same as the DID.
    /// `public_key` is the public key and it is accepted and stored as raw bytes.
    pub struct KeyDetail {
        controller: Did,
        public_key: PublicKey,
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for KeyDetail {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                __codec_dest_edqy.push(&self.controller);
                __codec_dest_edqy.push(&self.public_key);
            }
        }
        impl _parity_scale_codec::EncodeLike for KeyDetail {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for KeyDetail {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(KeyDetail {
                    controller: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err("Error decoding field KeyDetail.controller".into())
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    public_key: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err("Error decoding field KeyDetail.public_key".into())
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for KeyDetail {
        #[inline]
        fn clone(&self) -> KeyDetail {
            match *self {
                KeyDetail {
                    controller: ref __self_0_0,
                    public_key: ref __self_0_1,
                } => KeyDetail {
                    controller: ::core::clone::Clone::clone(&(*__self_0_0)),
                    public_key: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for KeyDetail {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for KeyDetail {
        #[inline]
        fn eq(&self, other: &KeyDetail) -> bool {
            match *other {
                KeyDetail {
                    controller: ref __self_1_0,
                    public_key: ref __self_1_1,
                } => match *self {
                    KeyDetail {
                        controller: ref __self_0_0,
                        public_key: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &KeyDetail) -> bool {
            match *other {
                KeyDetail {
                    controller: ref __self_1_0,
                    public_key: ref __self_1_1,
                } => match *self {
                    KeyDetail {
                        controller: ref __self_0_0,
                        public_key: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for KeyDetail {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                KeyDetail {
                    controller: ref __self_0_0,
                    public_key: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("KeyDetail");
                    let _ = debug_trait_builder.field("controller", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("public_key", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for KeyDetail {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "KeyDetail",
                    false as usize + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "controller",
                    &self.controller,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "public_key",
                    &self.public_key,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for KeyDetail {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "controller" => _serde::__private::Ok(__Field::__field0),
                            "public_key" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"controller" => _serde::__private::Ok(__Field::__field0),
                            b"public_key" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<KeyDetail>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = KeyDetail;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct KeyDetail")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<Did>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct KeyDetail with 2 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<PublicKey>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct KeyDetail with 2 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(KeyDetail {
                            controller: __field0,
                            public_key: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Did> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<PublicKey> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "controller",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Did>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "public_key",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<PublicKey>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("controller") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("public_key") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(KeyDetail {
                            controller: __field0,
                            public_key: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["controller", "public_key"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "KeyDetail",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<KeyDetail>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl KeyDetail {
        /// Create new key detail
        pub fn new(controller: Did, public_key: PublicKey) -> Self {
            KeyDetail {
                controller,
                public_key,
            }
        }
    }
    /// This struct is passed as an argument while updating the key for a DID.
    /// `did` is the DID whose key is being updated.
    /// `public_key` the new public key
    /// `controller` If provided None, the controller is unchanged. While serializing, use literal
    /// "None" when controller is None.
    /// The last_modified_in_block is the block number when this DID was last modified. It is used to
    /// prevent replay attacks. This approach allows easy submission of 1 update transaction in a block.
    /// It's theoretically possible to submit more than one txn per block, but the method is
    /// non-trivial and potentially unreliable.
    /// An alternate approach can be to have a nonce associated to each detail which is incremented on each
    /// successful extrinsic and the chain requiring the extrinsic's nonce to be higher than current.
    /// This is little more involved as it involves a ">" check
    pub struct KeyUpdate {
        pub did: Did,
        pub public_key: PublicKey,
        pub controller: Option<Did>,
        pub last_modified_in_block: BlockNumber,
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for KeyUpdate {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                __codec_dest_edqy.push(&self.did);
                __codec_dest_edqy.push(&self.public_key);
                __codec_dest_edqy.push(&self.controller);
                __codec_dest_edqy.push(&self.last_modified_in_block);
            }
        }
        impl _parity_scale_codec::EncodeLike for KeyUpdate {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for KeyUpdate {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(KeyUpdate {
                    did: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field KeyUpdate.did".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    public_key: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err("Error decoding field KeyUpdate.public_key".into())
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    controller: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err("Error decoding field KeyUpdate.controller".into())
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    last_modified_in_block: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err(
                                    "Error decoding field KeyUpdate.last_modified_in_block".into()
                                )
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for KeyUpdate {
        #[inline]
        fn clone(&self) -> KeyUpdate {
            match *self {
                KeyUpdate {
                    did: ref __self_0_0,
                    public_key: ref __self_0_1,
                    controller: ref __self_0_2,
                    last_modified_in_block: ref __self_0_3,
                } => KeyUpdate {
                    did: ::core::clone::Clone::clone(&(*__self_0_0)),
                    public_key: ::core::clone::Clone::clone(&(*__self_0_1)),
                    controller: ::core::clone::Clone::clone(&(*__self_0_2)),
                    last_modified_in_block: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for KeyUpdate {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for KeyUpdate {
        #[inline]
        fn eq(&self, other: &KeyUpdate) -> bool {
            match *other {
                KeyUpdate {
                    did: ref __self_1_0,
                    public_key: ref __self_1_1,
                    controller: ref __self_1_2,
                    last_modified_in_block: ref __self_1_3,
                } => match *self {
                    KeyUpdate {
                        did: ref __self_0_0,
                        public_key: ref __self_0_1,
                        controller: ref __self_0_2,
                        last_modified_in_block: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &KeyUpdate) -> bool {
            match *other {
                KeyUpdate {
                    did: ref __self_1_0,
                    public_key: ref __self_1_1,
                    controller: ref __self_1_2,
                    last_modified_in_block: ref __self_1_3,
                } => match *self {
                    KeyUpdate {
                        did: ref __self_0_0,
                        public_key: ref __self_0_1,
                        controller: ref __self_0_2,
                        last_modified_in_block: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for KeyUpdate {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                KeyUpdate {
                    did: ref __self_0_0,
                    public_key: ref __self_0_1,
                    controller: ref __self_0_2,
                    last_modified_in_block: ref __self_0_3,
                } => {
                    let mut debug_trait_builder = f.debug_struct("KeyUpdate");
                    let _ = debug_trait_builder.field("did", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("public_key", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("controller", &&(*__self_0_2));
                    let _ = debug_trait_builder.field("last_modified_in_block", &&(*__self_0_3));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for KeyUpdate {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "KeyUpdate",
                    false as usize + 1 + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "did",
                    &self.did,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "public_key",
                    &self.public_key,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "controller",
                    &self.controller,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "last_modified_in_block",
                    &self.last_modified_in_block,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for KeyUpdate {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "did" => _serde::__private::Ok(__Field::__field0),
                            "public_key" => _serde::__private::Ok(__Field::__field1),
                            "controller" => _serde::__private::Ok(__Field::__field2),
                            "last_modified_in_block" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"did" => _serde::__private::Ok(__Field::__field0),
                            b"public_key" => _serde::__private::Ok(__Field::__field1),
                            b"controller" => _serde::__private::Ok(__Field::__field2),
                            b"last_modified_in_block" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<KeyUpdate>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = KeyUpdate;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct KeyUpdate")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<Did>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct KeyUpdate with 4 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<PublicKey>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct KeyUpdate with 4 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<Option<Did>>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct KeyUpdate with 4 elements",
                                ));
                            }
                        };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<BlockNumber>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct KeyUpdate with 4 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(KeyUpdate {
                            did: __field0,
                            public_key: __field1,
                            controller: __field2,
                            last_modified_in_block: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Did> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<PublicKey> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<Did>> =
                            _serde::__private::None;
                        let mut __field3: _serde::__private::Option<BlockNumber> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "did",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Did>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "public_key",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<PublicKey>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "controller",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<Did>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "last_modified_in_block",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<BlockNumber>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("did") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("public_key") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("controller") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("last_modified_in_block")
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(KeyUpdate {
                            did: __field0,
                            public_key: __field1,
                            controller: __field2,
                            last_modified_in_block: __field3,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] =
                    &["did", "public_key", "controller", "last_modified_in_block"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "KeyUpdate",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<KeyUpdate>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl KeyUpdate {
        /// Create new key update to update key of the `did`.
        /// Pass `controller` as None when not wishing to change the existing controller
        pub fn new(
            did: Did,
            public_key: PublicKey,
            controller: Option<Did>,
            last_modified_in_block: BlockNumber,
        ) -> Self {
            KeyUpdate {
                did,
                public_key,
                controller,
                last_modified_in_block,
            }
        }
    }
    /// This struct is passed as an argument while removing the DID
    /// `did` is the DID which is being removed.
    /// `last_modified_in_block` is the block number when this DID was last modified. The last modified time is present to prevent replay attack.
    pub struct DidRemoval {
        pub did: Did,
        pub last_modified_in_block: BlockNumber,
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for DidRemoval {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                __codec_dest_edqy.push(&self.did);
                __codec_dest_edqy.push(&self.last_modified_in_block);
            }
        }
        impl _parity_scale_codec::EncodeLike for DidRemoval {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for DidRemoval {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(DidRemoval {
                    did: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field DidRemoval.did".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    last_modified_in_block: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err(
                                    "Error decoding field DidRemoval.last_modified_in_block".into(),
                                )
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for DidRemoval {
        #[inline]
        fn clone(&self) -> DidRemoval {
            match *self {
                DidRemoval {
                    did: ref __self_0_0,
                    last_modified_in_block: ref __self_0_1,
                } => DidRemoval {
                    did: ::core::clone::Clone::clone(&(*__self_0_0)),
                    last_modified_in_block: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for DidRemoval {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for DidRemoval {
        #[inline]
        fn eq(&self, other: &DidRemoval) -> bool {
            match *other {
                DidRemoval {
                    did: ref __self_1_0,
                    last_modified_in_block: ref __self_1_1,
                } => match *self {
                    DidRemoval {
                        did: ref __self_0_0,
                        last_modified_in_block: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &DidRemoval) -> bool {
            match *other {
                DidRemoval {
                    did: ref __self_1_0,
                    last_modified_in_block: ref __self_1_1,
                } => match *self {
                    DidRemoval {
                        did: ref __self_0_0,
                        last_modified_in_block: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for DidRemoval {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                DidRemoval {
                    did: ref __self_0_0,
                    last_modified_in_block: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("DidRemoval");
                    let _ = debug_trait_builder.field("did", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("last_modified_in_block", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DidRemoval {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "DidRemoval",
                    false as usize + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "did",
                    &self.did,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "last_modified_in_block",
                    &self.last_modified_in_block,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DidRemoval {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "did" => _serde::__private::Ok(__Field::__field0),
                            "last_modified_in_block" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"did" => _serde::__private::Ok(__Field::__field0),
                            b"last_modified_in_block" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DidRemoval>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DidRemoval;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct DidRemoval")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<Did>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DidRemoval with 2 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<BlockNumber>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct DidRemoval with 2 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(DidRemoval {
                            did: __field0,
                            last_modified_in_block: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Did> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<BlockNumber> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "did",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Did>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "last_modified_in_block",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<BlockNumber>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("did") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("last_modified_in_block")
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(DidRemoval {
                            did: __field0,
                            last_modified_in_block: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["did", "last_modified_in_block"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DidRemoval",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DidRemoval>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl DidRemoval {
        /// Remove an existing DID `did`
        pub fn new(did: Did, last_modified_in_block: BlockNumber) -> Self {
            DidRemoval {
                did,
                last_modified_in_block,
            }
        }
    }
    /// Events for this module.
    ///
    pub enum Event {
        DidAdded(dock::did::Did),
        KeyUpdated(dock::did::Did),
        DidRemoved(dock::did::Did),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Event {
        #[inline]
        fn clone(&self) -> Event {
            match (&*self,) {
                (&Event::DidAdded(ref __self_0),) => {
                    Event::DidAdded(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Event::KeyUpdated(ref __self_0),) => {
                    Event::KeyUpdated(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Event::DidRemoved(ref __self_0),) => {
                    Event::DidRemoved(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Event {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Event {
        #[inline]
        fn eq(&self, other: &Event) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Event::DidAdded(ref __self_0), &Event::DidAdded(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Event::KeyUpdated(ref __self_0), &Event::KeyUpdated(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Event::DidRemoved(ref __self_0), &Event::DidRemoved(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Event) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Event::DidAdded(ref __self_0), &Event::DidAdded(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Event::KeyUpdated(ref __self_0), &Event::KeyUpdated(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Event::DidRemoved(ref __self_0), &Event::DidRemoved(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for Event {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Event {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<dock::did::Did>;
                let _: ::core::cmp::AssertParamIsEq<dock::did::Did>;
                let _: ::core::cmp::AssertParamIsEq<dock::did::Did>;
            }
        }
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for Event {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    Event::DidAdded(ref aa) => {
                        __codec_dest_edqy.push_byte(0usize as u8);
                        __codec_dest_edqy.push(aa);
                    }
                    Event::KeyUpdated(ref aa) => {
                        __codec_dest_edqy.push_byte(1usize as u8);
                        __codec_dest_edqy.push(aa);
                    }
                    Event::DidRemoved(ref aa) => {
                        __codec_dest_edqy.push_byte(2usize as u8);
                        __codec_dest_edqy.push(aa);
                    }
                    _ => (),
                }
            }
        }
        impl _parity_scale_codec::EncodeLike for Event {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for Event {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                match __codec_input_edqy.read_byte()? {
                    __codec_x_edqy if __codec_x_edqy == 0usize as u8 => Ok(Event::DidAdded({
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Event :: DidAdded.0".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    })),
                    __codec_x_edqy if __codec_x_edqy == 1usize as u8 => Ok(Event::KeyUpdated({
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err("Error decoding field Event :: KeyUpdated.0".into())
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    })),
                    __codec_x_edqy if __codec_x_edqy == 2usize as u8 => Ok(Event::DidRemoved({
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err("Error decoding field Event :: DidRemoved.0".into())
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    })),
                    _ => Err("No such variant in enum Event".into()),
                }
            }
        }
    };
    impl core::fmt::Debug for Event {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self {
                Self::DidAdded(ref a0) => fmt.debug_tuple("Event::DidAdded").field(a0).finish(),
                Self::KeyUpdated(ref a0) => fmt.debug_tuple("Event::KeyUpdated").field(a0).finish(),
                Self::DidRemoved(ref a0) => fmt.debug_tuple("Event::DidRemoved").field(a0).finish(),
                _ => Ok(()),
            }
        }
    }
    impl From<Event> for () {
        fn from(_: Event) -> () {
            ()
        }
    }
    impl Event {
        #[allow(dead_code)]
        #[doc(hidden)]
        pub fn metadata() -> &'static [::frame_support::event::EventMetadata] {
            &[
                ::frame_support::event::EventMetadata {
                    name: ::frame_support::event::DecodeDifferent::Encode("DidAdded"),
                    arguments: ::frame_support::event::DecodeDifferent::Encode(&["dock::did::Did"]),
                    documentation: ::frame_support::event::DecodeDifferent::Encode(&[]),
                },
                ::frame_support::event::EventMetadata {
                    name: ::frame_support::event::DecodeDifferent::Encode("KeyUpdated"),
                    arguments: ::frame_support::event::DecodeDifferent::Encode(&["dock::did::Did"]),
                    documentation: ::frame_support::event::DecodeDifferent::Encode(&[]),
                },
                ::frame_support::event::EventMetadata {
                    name: ::frame_support::event::DecodeDifferent::Encode("DidRemoved"),
                    arguments: ::frame_support::event::DecodeDifferent::Encode(&["dock::did::Did"]),
                    documentation: ::frame_support::event::DecodeDifferent::Encode(&[]),
                },
            ]
        }
    }
    use self::sp_api_hidden_includes_decl_storage::hidden_include::{
        StorageValue as _, StorageMap as _, StorageDoubleMap as _, StoragePrefixedMap as _,
        IterableStorageMap as _, IterableStorageDoubleMap as _,
    };
    #[doc(hidden)]
    mod sp_api_hidden_includes_decl_storage {
        pub extern crate frame_support as hidden_include;
    }
    trait Store {
        type Dids;
    }
    impl<T: Trait + 'static> Store for Module<T> {
        type Dids = Dids<T>;
    }
    impl<T: Trait + 'static> Module<T> {
        pub fn did<
            K: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<
                dock::did::Did,
            >,
        >(
            key: K,
        ) -> Option<(dock::did::KeyDetail, T::BlockNumber)> {
            < Dids < T > as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: storage :: StorageMap < dock :: did :: Did , (dock :: did :: KeyDetail , T :: BlockNumber) > > :: get (key)
        }
    }
    #[doc(hidden)]
    pub struct __GetByteStructDids<T>(
        pub  self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<
            (T),
        >,
    );
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_Dids:
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<
            self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>,
        > =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl<T: Trait> self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
        for __GetByteStructDids<T>
    {
        fn default_byte(
            &self,
        ) -> self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>
        {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_Dids
                .get_or_init(|| {
                    let def_val: Option<(dock::did::KeyDetail, T::BlockNumber)> =
                        Default::default();
                    <Option<(dock::did::KeyDetail, T::BlockNumber)> as Encode>::encode(&def_val)
                })
                .clone()
        }
    }
    unsafe impl<T: Trait> Send for __GetByteStructDids<T> {}
    unsafe impl<T: Trait> Sync for __GetByteStructDids<T> {}
    impl<T: Trait + 'static> Module<T> {
        #[doc(hidden)]
        pub fn storage_metadata(
        ) -> self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageMetadata
        {
            self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageMetadata { prefix : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("DIDModule") , entries : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (& [self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryMetadata { name : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("Dids") , modifier : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryModifier :: Optional , ty : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryType :: Map { hasher : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageHasher :: Blake2_128Concat , key : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("dock::did::Did") , value : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("(dock::did::KeyDetail, T::BlockNumber)") , unused : false , } , default : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DefaultByteGetter (& __GetByteStructDids :: < T > (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_std :: marker :: PhantomData))) , documentation : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (& []) , }] [..]) , }
        }
    }
    /// Hidden instance generated to be internally used when module is used without
    /// instance.
    #[doc(hidden)]
    pub struct __InherentHiddenInstance;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for __InherentHiddenInstance {
        #[inline]
        fn clone(&self) -> __InherentHiddenInstance {
            match *self {
                __InherentHiddenInstance => __InherentHiddenInstance,
            }
        }
    }
    impl ::core::marker::StructuralEq for __InherentHiddenInstance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for __InherentHiddenInstance {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    impl ::core::marker::StructuralPartialEq for __InherentHiddenInstance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for __InherentHiddenInstance {
        #[inline]
        fn eq(&self, other: &__InherentHiddenInstance) -> bool {
            match *other {
                __InherentHiddenInstance => match *self {
                    __InherentHiddenInstance => true,
                },
            }
        }
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for __InherentHiddenInstance {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
            }
        }
        impl _parity_scale_codec::EncodeLike for __InherentHiddenInstance {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for __InherentHiddenInstance {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(__InherentHiddenInstance)
            }
        }
    };
    impl core::fmt::Debug for __InherentHiddenInstance {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("__InherentHiddenInstance").finish()
        }
    }
    impl self::sp_api_hidden_includes_decl_storage::hidden_include::traits::Instance
        for __InherentHiddenInstance
    {
        const PREFIX: &'static str = "DIDModule";
    }
    /// Genesis config for the module, allow to build genesis storage.
    #[cfg(feature = "std")]
    #[serde(rename_all = "camelCase")]
    #[serde(deny_unknown_fields)]
    #[serde(bound(
        serialize = "Vec < (Did, KeyDetail) > : self :: sp_api_hidden_includes_decl_storage :: hidden_include::serde::Serialize, "
    ))]
    #[serde(bound(
        deserialize = "Vec < (Did, KeyDetail) > : self :: sp_api_hidden_includes_decl_storage :: hidden_include::serde::de::DeserializeOwned, "
    ))]
    pub struct GenesisConfig {
        pub dids: Vec<(Did, KeyDetail)>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for GenesisConfig
        where
            Vec<(Did, KeyDetail)>:
                self::sp_api_hidden_includes_decl_storage::hidden_include::serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "GenesisConfig",
                    false as usize + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dids",
                    &self.dids,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl < 'de > _serde :: Deserialize < 'de > for GenesisConfig where Vec < (Did , KeyDetail) > : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: serde :: de :: DeserializeOwned { fn deserialize < __D > (__deserializer : __D) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { # [allow (non_camel_case_types)] enum __Field { __field0 , } struct __FieldVisitor ; impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "field identifier") } fn visit_u64 < __E > (self , __value : u64) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , _ => _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "field index 0 <= i < 1")) , } } fn visit_str < __E > (self , __value : & str) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { "dids" => _serde :: __private :: Ok (__Field :: __field0) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_field (__value , FIELDS)) } } } fn visit_bytes < __E > (self , __value : & [u8]) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { b"dids" => _serde :: __private :: Ok (__Field :: __field0) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_field (__value , FIELDS)) } } } } impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor) } } struct __Visitor < 'de > where Vec < (Did , KeyDetail) > : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: serde :: de :: DeserializeOwned { marker : _serde :: __private :: PhantomData < GenesisConfig > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > where Vec < (Did , KeyDetail) > : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: serde :: de :: DeserializeOwned { type Value = GenesisConfig ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "struct GenesisConfig") } # [inline] fn visit_seq < __A > (self , mut __seq : __A) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > { let __field0 = match match _serde :: de :: SeqAccess :: next_element :: < Vec < (Did , KeyDetail) > > (& mut __seq) { _serde :: __private :: Ok (__val) => __val , _serde :: __private :: Err (__err) => { return _serde :: __private :: Err (__err) ; } } { _serde :: __private :: Some (__value) => __value , _serde :: __private :: None => { return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct GenesisConfig with 1 element")) ; } } ; _serde :: __private :: Ok (GenesisConfig { dids : __field0 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > { let mut __field0 : _serde :: __private :: Option < Vec < (Did , KeyDetail) > > = _serde :: __private :: None ; while let _serde :: __private :: Some (__key) = match _serde :: de :: MapAccess :: next_key :: < __Field > (& mut __map) { _serde :: __private :: Ok (__val) => __val , _serde :: __private :: Err (__err) => { return _serde :: __private :: Err (__err) ; } } { match __key { __Field :: __field0 => { if _serde :: __private :: Option :: is_some (& __field0) { return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("dids")) ; } __field0 = _serde :: __private :: Some (match _serde :: de :: MapAccess :: next_value :: < Vec < (Did , KeyDetail) > > (& mut __map) { _serde :: __private :: Ok (__val) => __val , _serde :: __private :: Err (__err) => { return _serde :: __private :: Err (__err) ; } }) ; } } } let __field0 = match __field0 { _serde :: __private :: Some (__field0) => __field0 , _serde :: __private :: None => match _serde :: __private :: de :: missing_field ("dids") { _serde :: __private :: Ok (__val) => __val , _serde :: __private :: Err (__err) => { return _serde :: __private :: Err (__err) ; } } , } ; _serde :: __private :: Ok (GenesisConfig { dids : __field0 , }) } } const FIELDS : & 'static [& 'static str] = & ["dids"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "GenesisConfig" , FIELDS , __Visitor { marker : _serde :: __private :: PhantomData :: < GenesisConfig > , lifetime : _serde :: __private :: PhantomData , }) } }
    };
    #[cfg(feature = "std")]
    impl Default for GenesisConfig {
        fn default() -> Self {
            GenesisConfig {
                dids: Default::default(),
            }
        }
    }
    #[cfg(feature = "std")]
    impl GenesisConfig {
        /// Build the storage for this module.
        pub fn build_storage<T: Trait>(
            &self,
        ) -> std::result::Result<
            self::sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::Storage,
            String,
        > {
            let mut storage = Default::default();
            self.assimilate_storage::<T>(&mut storage)?;
            Ok(storage)
        }
        /// Assimilate the storage for this module into pre-existing overlays.
        pub fn assimilate_storage<T: Trait>(
            &self,
            storage : & mut self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_runtime :: Storage,
        ) -> std::result::Result<(), String> {
            self :: sp_api_hidden_includes_decl_storage :: hidden_include :: BasicExternalities :: execute_with_storage (storage , | | { let extra_genesis_builder : fn (& Self) = | slef : & Self | { if true { if ! { let mut dedup : Vec < & Did > = slef . dids . iter () . map (| (d , _kd) | d) . collect () ; dedup . sort () ; dedup . dedup () ; slef . dids . len () == dedup . len () } { :: core :: panicking :: panic ("assertion failed: {\\n    let mut dedup: Vec<&Did> = slef.dids.iter().map(|(d, _kd)| d).collect();\\n    dedup.sort();\\n    dedup.dedup();\\n    slef.dids.len() == dedup.len()\\n}") } ; } ; let block_no : T :: BlockNumber = 0u32 . into () ; for (did , deet) in slef . dids . iter () { Dids :: < T > :: insert (did , (deet , block_no)) ; } } ; extra_genesis_builder (self) ; Ok (()) })
        }
    }
    #[cfg(feature = "std")]
    impl < T : Trait , __GeneratedInstance : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_runtime :: BuildModuleGenesisStorage < T , __GeneratedInstance > for GenesisConfig { fn build_module_genesis_storage (& self , storage : & mut self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_runtime :: Storage) -> std :: result :: Result < () , String > { self . assimilate_storage :: < T > (storage) } }
    pub struct Dids<T: Trait>(
        self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<
                (T,),
            >,
    );
    impl<T: Trait>
        self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StoragePrefixedMap<(
            dock::did::KeyDetail,
            T::BlockNumber,
        )> for Dids<T>
    {
        fn module_prefix() -> &'static [u8] {
            < __InherentHiddenInstance as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > :: PREFIX . as_bytes ()
        }
        fn storage_prefix() -> &'static [u8] {
            b"Dids"
        }
    }
    impl<T: Trait>
        self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<
            dock::did::Did,
            (dock::did::KeyDetail, T::BlockNumber),
        > for Dids<T>
    {
        type Query = Option<(dock::did::KeyDetail, T::BlockNumber)>;
        type Hasher = self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_128Concat;
        fn module_prefix() -> &'static [u8] {
            < __InherentHiddenInstance as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > :: PREFIX . as_bytes ()
        }
        fn storage_prefix() -> &'static [u8] {
            b"Dids"
        }
        fn from_optional_value_to_query(
            v: Option<(dock::did::KeyDetail, T::BlockNumber)>,
        ) -> Self::Query {
            v.or_else(|| Default::default())
        }
        fn from_query_to_optional_value(
            v: Self::Query,
        ) -> Option<(dock::did::KeyDetail, T::BlockNumber)> {
            v
        }
    }
    pub struct Module<T: Trait>(::frame_support::sp_std::marker::PhantomData<(T,)>);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::clone::Clone + Trait> ::core::clone::Clone for Module<T> {
        #[inline]
        fn clone(&self) -> Module<T> {
            match *self {
                Module(ref __self_0_0) => Module(::core::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::marker::Copy + Trait> ::core::marker::Copy for Module<T> {}
    impl<T: Trait> ::core::marker::StructuralPartialEq for Module<T> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::cmp::PartialEq + Trait> ::core::cmp::PartialEq for Module<T> {
        #[inline]
        fn eq(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) => match *self {
                    Module(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) => match *self {
                    Module(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl<T: Trait> ::core::marker::StructuralEq for Module<T> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::cmp::Eq + Trait> ::core::cmp::Eq for Module<T> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<
                    ::frame_support::sp_std::marker::PhantomData<(T,)>,
                >;
            }
        }
    }
    impl<T: Trait> core::fmt::Debug for Module<T>
    where
        T: core::fmt::Debug,
    {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("Module").field(&self.0).finish()
        }
    }
    impl<T: frame_system::Config + Trait>
        ::frame_support::traits::OnInitialize<<T as frame_system::Config>::BlockNumber>
        for Module<T>
    {
    }
    impl<T: Trait> ::frame_support::traits::OnRuntimeUpgrade for Module<T> {
        fn on_runtime_upgrade() -> ::frame_support::dispatch::Weight {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "on_runtime_upgrade",
                            "core_mods::did",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/did.rs"),
                            Some(318u32),
                            Some("core_mods::did"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
            .put_into_storage::<<T as frame_system::Config>::PalletInfo, Self>();
            <<T as frame_system::Config>::DbWeight as ::frame_support::traits::Get<_>>::get()
                .writes(1)
        }
    }
    impl<T: frame_system::Config + Trait>
        ::frame_support::traits::OnFinalize<<T as frame_system::Config>::BlockNumber>
        for Module<T>
    {
    }
    impl<T: frame_system::Config + Trait>
        ::frame_support::traits::OffchainWorker<<T as frame_system::Config>::BlockNumber>
        for Module<T>
    {
    }
    impl<T: Trait> Module<T> {
        /// Deposits an event using `frame_system::Module::deposit_event`.
        fn deposit_event(event: impl Into<<T as Trait>::Event>) {
            <frame_system::Module<T>>::deposit_event(event.into())
        }
    }
    #[cfg(feature = "std")]
    impl<T: Trait> ::frame_support::traits::IntegrityTest for Module<T> {}
    /// Can also be called using [`Call`].
    ///
    /// [`Call`]: enum.Call.html
    impl<T: Trait> Module<T> {
        /// Create a new DID.
        /// `did` is the new DID to create. The method will fail if `did` is already registered.
        /// `detail` is the details of the key like its type, controller and value. The controller DID
        /// is not required to exist in the state.
        ///
        /// NOTE: Calling this function will bypass origin filters.
        pub fn new(
            origin: T::Origin,
            did: dock::did::Did,
            detail: dock::did::KeyDetail,
        ) -> DispatchResult {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "new",
                            "core_mods::did",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/did.rs"),
                            Some(318u32),
                            Some("core_mods::did"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            ensure_signed(origin)?;
            {
                if !!Dids::<T>::contains_key(did) {
                    {
                        return Err(Error::<T>::DidAlreadyExists.into());
                    };
                }
            };
            let current_block_no = <system::Module<T>>::block_number();
            Dids::<T>::insert(did, (detail, current_block_no));
            Self::deposit_event(Event::DidAdded(did));
            Ok(())
        }
        /// Sets the single publicKey (and possibly its controller) stored in this DID.
        ///
        /// `key_update` specifies which DID's key needs to be updated. The new controller DID
        /// is not required to exist in the state.
        /// `signature` is the signature on a serialized [StateChange][statechange] that wraps the
        /// [KeyUpdate][keyupdate] struct
        ///
        /// During execution this function checks for a signature over [StateChange][statechange]
        /// and verifies the given signature with the stored key.
        ///
        /// [statechange]: ../enum.StateChange.html
        /// [keyupdate]: ./struct.KeyUpdate.html
        /// # <weight>
        /// This call requires a signature verification and the cost of verification varies by type
        /// of signature
        /// # </weight>
        ///
        /// NOTE: Calling this function will bypass origin filters.
        pub fn update_key(
            origin: T::Origin,
            key_update: dock::did::KeyUpdate,
            signature: dock::did::DidSignature,
        ) -> DispatchResult {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "update_key",
                            "core_mods::did",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/did.rs"),
                            Some(318u32),
                            Some("core_mods::did"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            ensure_signed(origin)?;
            let mut current_key_detail = Self::ensure_did_registered_and_payload_fresh(
                &key_update.did,
                key_update.last_modified_in_block,
            )?;
            let serz_key_update = StateChange::KeyUpdate(key_update.clone()).encode();
            let sig_ver = Self::verify_sig_with_public_key(
                &signature,
                &serz_key_update,
                &current_key_detail.public_key,
            )?;
            {
                if !sig_ver {
                    {
                        return Err(Error::<T>::InvalidSig.into());
                    };
                }
            };
            let current_block_no = <system::Module<T>>::block_number();
            current_key_detail.public_key = key_update.public_key;
            if let Some(ctrl) = key_update.controller {
                current_key_detail.controller = ctrl;
            }
            Dids::<T>::insert(key_update.did, (current_key_detail, current_block_no));
            Self::deposit_event(Event::KeyUpdated(key_update.did));
            Ok(())
        }
        /// Deletes a DID from chain storage. Once the DID is deleted, anyone can call new to claim
        /// it for their own.
        ///
        /// `to_remove` contains the DID to be removed
        /// `signature` is the signature on a serialized [StateChange][statechange] that wraps the
        /// [DidRemoval][didremoval] struct
        ///
        /// During execution this function checks for a signature over [StateChange][statechange]
        /// and verifies the given signature with the stored key.
        ///
        /// [statechange]: ../enum.StateChange.html
        /// [didremoval]: ./struct.DidRemoval.html
        /// # <weight>
        /// This call requires a signature verification and the cost of verification varies by type
        /// of signature
        /// # </weight>
        ///
        /// NOTE: Calling this function will bypass origin filters.
        pub fn remove(
            origin: T::Origin,
            to_remove: dock::did::DidRemoval,
            signature: dock::did::DidSignature,
        ) -> DispatchResult {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "remove",
                            "core_mods::did",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/did.rs"),
                            Some(318u32),
                            Some("core_mods::did"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            ensure_signed(origin)?;
            let current_key_detail = Self::ensure_did_registered_and_payload_fresh(
                &to_remove.did,
                to_remove.last_modified_in_block,
            )?;
            let did = to_remove.did;
            let serz_rem = StateChange::DIDRemoval(to_remove).encode();
            let sig_ver = Self::verify_sig_with_public_key(
                &signature,
                &serz_rem,
                &current_key_detail.public_key,
            )?;
            {
                if !sig_ver {
                    {
                        return Err(Error::<T>::InvalidSig.into());
                    };
                }
            };
            Dids::<T>::remove(did);
            Self::deposit_event(Event::DidRemoved(did));
            Ok(())
        }
    }
    /// Dispatchable calls.
    ///
    /// Each variant of this enum maps to a dispatchable function from the associated module.
    pub enum Call<T: Trait> {
        #[doc(hidden)]
        #[codec(skip)]
        __PhantomItem(
            ::frame_support::sp_std::marker::PhantomData<(T,)>,
            ::frame_support::Never,
        ),
        #[allow(non_camel_case_types)]
        /// Create a new DID.
        /// `did` is the new DID to create. The method will fail if `did` is already registered.
        /// `detail` is the details of the key like its type, controller and value. The controller DID
        /// is not required to exist in the state.
        new(dock::did::Did, dock::did::KeyDetail),
        #[allow(non_camel_case_types)]
        /// Sets the single publicKey (and possibly its controller) stored in this DID.
        ///
        /// `key_update` specifies which DID's key needs to be updated. The new controller DID
        /// is not required to exist in the state.
        /// `signature` is the signature on a serialized [StateChange][statechange] that wraps the
        /// [KeyUpdate][keyupdate] struct
        ///
        /// During execution this function checks for a signature over [StateChange][statechange]
        /// and verifies the given signature with the stored key.
        ///
        /// [statechange]: ../enum.StateChange.html
        /// [keyupdate]: ./struct.KeyUpdate.html
        /// # <weight>
        /// This call requires a signature verification and the cost of verification varies by type
        /// of signature
        /// # </weight>
        update_key(dock::did::KeyUpdate, dock::did::DidSignature),
        #[allow(non_camel_case_types)]
        /// Deletes a DID from chain storage. Once the DID is deleted, anyone can call new to claim
        /// it for their own.
        ///
        /// `to_remove` contains the DID to be removed
        /// `signature` is the signature on a serialized [StateChange][statechange] that wraps the
        /// [DidRemoval][didremoval] struct
        ///
        /// During execution this function checks for a signature over [StateChange][statechange]
        /// and verifies the given signature with the stored key.
        ///
        /// [statechange]: ../enum.StateChange.html
        /// [didremoval]: ./struct.DidRemoval.html
        /// # <weight>
        /// This call requires a signature verification and the cost of verification varies by type
        /// of signature
        /// # </weight>
        remove(dock::did::DidRemoval, dock::did::DidSignature),
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl<T: Trait> _parity_scale_codec::Encode for Call<T> {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    Call::new(ref aa, ref ba) => {
                        __codec_dest_edqy.push_byte(0usize as u8);
                        __codec_dest_edqy.push(aa);
                        __codec_dest_edqy.push(ba);
                    }
                    Call::update_key(ref aa, ref ba) => {
                        __codec_dest_edqy.push_byte(1usize as u8);
                        __codec_dest_edqy.push(aa);
                        __codec_dest_edqy.push(ba);
                    }
                    Call::remove(ref aa, ref ba) => {
                        __codec_dest_edqy.push_byte(2usize as u8);
                        __codec_dest_edqy.push(aa);
                        __codec_dest_edqy.push(ba);
                    }
                    _ => (),
                }
            }
        }
        impl<T: Trait> _parity_scale_codec::EncodeLike for Call<T> {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl<T: Trait> _parity_scale_codec::Decode for Call<T> {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                match __codec_input_edqy.read_byte()? {
                    __codec_x_edqy if __codec_x_edqy == 0usize as u8 => Ok(Call::new(
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => return Err("Error decoding field Call :: new.0".into()),
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => return Err("Error decoding field Call :: new.1".into()),
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    )),
                    __codec_x_edqy if __codec_x_edqy == 1usize as u8 => Ok(Call::update_key(
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err("Error decoding field Call :: update_key.0".into())
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err("Error decoding field Call :: update_key.1".into())
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    )),
                    __codec_x_edqy if __codec_x_edqy == 2usize as u8 => Ok(Call::remove(
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err("Error decoding field Call :: remove.0".into())
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err("Error decoding field Call :: remove.1".into())
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    )),
                    _ => Err("No such variant in enum Call".into()),
                }
            }
        }
    };
    impl<T: Trait> ::frame_support::dispatch::GetDispatchInfo for Call<T> {
        fn get_dispatch_info(&self) -> ::frame_support::dispatch::DispatchInfo {
            match *self {
                Call::new(ref did, ref detail) => {
                    let base_weight = T::DbWeight::get().reads_writes(1, 1) + 36_000_000;
                    let weight = <dyn ::frame_support::dispatch::WeighData<(
                        &dock::did::Did,
                        &dock::did::KeyDetail,
                    )>>::weigh_data(&base_weight, (did, detail));
                    let class =
                        <dyn ::frame_support::dispatch::ClassifyDispatch<(
                            &dock::did::Did,
                            &dock::did::KeyDetail,
                        )>>::classify_dispatch(&base_weight, (did, detail));
                    let pays_fee = <dyn ::frame_support::dispatch::PaysFee<(
                        &dock::did::Did,
                        &dock::did::KeyDetail,
                    )>>::pays_fee(&base_weight, (did, detail));
                    ::frame_support::dispatch::DispatchInfo {
                        weight,
                        class,
                        pays_fee,
                    }
                }
                Call::update_key(ref key_update, ref signature) => {
                    let base_weight = T::DbWeight::get().reads_writes(1, 1) + signature.weight();
                    let weight = <dyn ::frame_support::dispatch::WeighData<(
                        &dock::did::KeyUpdate,
                        &dock::did::DidSignature,
                    )>>::weigh_data(
                        &base_weight, (key_update, signature)
                    );
                    let class = <dyn ::frame_support::dispatch::ClassifyDispatch<(
                        &dock::did::KeyUpdate,
                        &dock::did::DidSignature,
                    )>>::classify_dispatch(
                        &base_weight, (key_update, signature)
                    );
                    let pays_fee =
                        <dyn ::frame_support::dispatch::PaysFee<(
                            &dock::did::KeyUpdate,
                            &dock::did::DidSignature,
                        )>>::pays_fee(&base_weight, (key_update, signature));
                    ::frame_support::dispatch::DispatchInfo {
                        weight,
                        class,
                        pays_fee,
                    }
                }
                Call::remove(ref to_remove, ref signature) => {
                    let base_weight = T::DbWeight::get().reads_writes(1, 1) + signature.weight();
                    let weight = <dyn ::frame_support::dispatch::WeighData<(
                        &dock::did::DidRemoval,
                        &dock::did::DidSignature,
                    )>>::weigh_data(
                        &base_weight, (to_remove, signature)
                    );
                    let class = <dyn ::frame_support::dispatch::ClassifyDispatch<(
                        &dock::did::DidRemoval,
                        &dock::did::DidSignature,
                    )>>::classify_dispatch(
                        &base_weight, (to_remove, signature)
                    );
                    let pays_fee =
                        <dyn ::frame_support::dispatch::PaysFee<(
                            &dock::did::DidRemoval,
                            &dock::did::DidSignature,
                        )>>::pays_fee(&base_weight, (to_remove, signature));
                    ::frame_support::dispatch::DispatchInfo {
                        weight,
                        class,
                        pays_fee,
                    }
                }
                Call::__PhantomItem(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__PhantomItem should never be used.",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::GetCallName for Call<T> {
        fn get_call_name(&self) -> &'static str {
            match *self {
                Call::new(ref did, ref detail) => {
                    let _ = (did, detail);
                    "new"
                }
                Call::update_key(ref key_update, ref signature) => {
                    let _ = (key_update, signature);
                    "update_key"
                }
                Call::remove(ref to_remove, ref signature) => {
                    let _ = (to_remove, signature);
                    "remove"
                }
                Call::__PhantomItem(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__PhantomItem should never be used.",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
        fn get_call_names() -> &'static [&'static str] {
            &["new", "update_key", "remove"]
        }
    }
    pub use ::frame_support::traits::GetPalletVersion as _;
    impl<T: Trait> ::frame_support::traits::GetPalletVersion for Module<T> {
        fn current_version() -> ::frame_support::traits::PalletVersion {
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
        }
        fn storage_version() -> Option<::frame_support::traits::PalletVersion> {
            let key = ::frame_support::traits::PalletVersion::storage_key::<
                <T as frame_system::Config>::PalletInfo,
                Self,
            >()
            .expect("Every active pallet has a name in the runtime; qed");
            ::frame_support::storage::unhashed::get(&key)
        }
    }
    impl<T: Trait> ::frame_support::traits::OnGenesis for Module<T> {
        fn on_genesis() {
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
            .put_into_storage::<<T as frame_system::Config>::PalletInfo, Self>();
        }
    }
    impl<T: Trait> ::frame_support::dispatch::Clone for Call<T> {
        fn clone(&self) -> Self {
            match *self {
                Call::new(ref did, ref detail) => Call::new((*did).clone(), (*detail).clone()),
                Call::update_key(ref key_update, ref signature) => {
                    Call::update_key((*key_update).clone(), (*signature).clone())
                }
                Call::remove(ref to_remove, ref signature) => {
                    Call::remove((*to_remove).clone(), (*signature).clone())
                }
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::PartialEq for Call<T> {
        fn eq(&self, _other: &Self) -> bool {
            match *self {
                Call::new(ref did, ref detail) => {
                    let self_params = (did, detail);
                    if let Call::new(ref did, ref detail) = *_other {
                        self_params == (did, detail)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                ::core::panicking::panic("internal error: entered unreachable code")
                            }
                            _ => false,
                        }
                    }
                }
                Call::update_key(ref key_update, ref signature) => {
                    let self_params = (key_update, signature);
                    if let Call::update_key(ref key_update, ref signature) = *_other {
                        self_params == (key_update, signature)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                ::core::panicking::panic("internal error: entered unreachable code")
                            }
                            _ => false,
                        }
                    }
                }
                Call::remove(ref to_remove, ref signature) => {
                    let self_params = (to_remove, signature);
                    if let Call::remove(ref to_remove, ref signature) = *_other {
                        self_params == (to_remove, signature)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                ::core::panicking::panic("internal error: entered unreachable code")
                            }
                            _ => false,
                        }
                    }
                }
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::Eq for Call<T> {}
    impl<T: Trait> ::frame_support::dispatch::fmt::Debug for Call<T> {
        fn fmt(
            &self,
            _f: &mut ::frame_support::dispatch::fmt::Formatter,
        ) -> ::frame_support::dispatch::result::Result<(), ::frame_support::dispatch::fmt::Error>
        {
            match *self {
                Call::new(ref did, ref detail) => _f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", ""],
                    &match (&"new", &(did.clone(), detail.clone())) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                        ],
                    },
                )),
                Call::update_key(ref key_update, ref signature) => {
                    _f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["", ""],
                        &match (&"update_key", &(key_update.clone(), signature.clone())) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                            ],
                        },
                    ))
                }
                Call::remove(ref to_remove, ref signature) => {
                    _f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["", ""],
                        &match (&"remove", &(to_remove.clone(), signature.clone())) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                            ],
                        },
                    ))
                }
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
    }
    impl<T: Trait> ::frame_support::traits::UnfilteredDispatchable for Call<T> {
        type Origin = T::Origin;
        fn dispatch_bypass_filter(
            self,
            _origin: Self::Origin,
        ) -> ::frame_support::dispatch::DispatchResultWithPostInfo {
            match self {
                Call::new(did, detail) => <Module<T>>::new(_origin, did, detail)
                    .map(Into::into)
                    .map_err(Into::into),
                Call::update_key(key_update, signature) => {
                    <Module<T>>::update_key(_origin, key_update, signature)
                        .map(Into::into)
                        .map_err(Into::into)
                }
                Call::remove(to_remove, signature) => {
                    <Module<T>>::remove(_origin, to_remove, signature)
                        .map(Into::into)
                        .map_err(Into::into)
                }
                Call::__PhantomItem(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__PhantomItem should never be used.",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::Callable<T> for Module<T> {
        type Call = Call<T>;
    }
    impl<T: Trait> Module<T> {
        #[doc(hidden)]
        #[allow(dead_code)]
        pub fn call_functions() -> &'static [::frame_support::dispatch::FunctionMetadata] {
            &[
                ::frame_support::dispatch::FunctionMetadata {
                    name: ::frame_support::dispatch::DecodeDifferent::Encode("new"),
                    arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("did"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                                "dock::did::Did",
                            ),
                        },
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("detail"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                                "dock::did::KeyDetail",
                            ),
                        },
                    ]),
                    documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        r" Create a new DID.",
                        r" `did` is the new DID to create. The method will fail if `did` is already registered.",
                        r" `detail` is the details of the key like its type, controller and value. The controller DID",
                        r" is not required to exist in the state.",
                    ]),
                },
                ::frame_support::dispatch::FunctionMetadata {
                    name: ::frame_support::dispatch::DecodeDifferent::Encode("update_key"),
                    arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("key_update"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                                "dock::did::KeyUpdate",
                            ),
                        },
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("signature"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                                "dock::did::DidSignature",
                            ),
                        },
                    ]),
                    documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        r" Sets the single publicKey (and possibly its controller) stored in this DID.",
                        r"",
                        r" `key_update` specifies which DID's key needs to be updated. The new controller DID",
                        r" is not required to exist in the state.",
                        r" `signature` is the signature on a serialized [StateChange][statechange] that wraps the",
                        r" [KeyUpdate][keyupdate] struct",
                        r"",
                        r" During execution this function checks for a signature over [StateChange][statechange]",
                        r" and verifies the given signature with the stored key.",
                        r"",
                        r" [statechange]: ../enum.StateChange.html",
                        r" [keyupdate]: ./struct.KeyUpdate.html",
                        r" # <weight>",
                        r" This call requires a signature verification and the cost of verification varies by type",
                        r" of signature",
                        r" # </weight>",
                    ]),
                },
                ::frame_support::dispatch::FunctionMetadata {
                    name: ::frame_support::dispatch::DecodeDifferent::Encode("remove"),
                    arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("to_remove"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                                "dock::did::DidRemoval",
                            ),
                        },
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("signature"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                                "dock::did::DidSignature",
                            ),
                        },
                    ]),
                    documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        r" Deletes a DID from chain storage. Once the DID is deleted, anyone can call new to claim",
                        r" it for their own.",
                        r"",
                        r" `to_remove` contains the DID to be removed",
                        r" `signature` is the signature on a serialized [StateChange][statechange] that wraps the",
                        r" [DidRemoval][didremoval] struct",
                        r"",
                        r" During execution this function checks for a signature over [StateChange][statechange]",
                        r" and verifies the given signature with the stored key.",
                        r"",
                        r" [statechange]: ../enum.StateChange.html",
                        r" [didremoval]: ./struct.DidRemoval.html",
                        r" # <weight>",
                        r" This call requires a signature verification and the cost of verification varies by type",
                        r" of signature",
                        r" # </weight>",
                    ]),
                },
            ]
        }
    }
    impl<T: 'static + Trait> Module<T> {
        #[doc(hidden)]
        #[allow(dead_code)]
        pub fn module_constants_metadata(
        ) -> &'static [::frame_support::dispatch::ModuleConstantMetadata] {
            &[]
        }
    }
    impl<T: Trait> ::frame_support::dispatch::ModuleErrorMetadata for Module<T> {
        fn metadata() -> &'static [::frame_support::dispatch::ErrorMetadata] {
            <Error<T> as ::frame_support::dispatch::ModuleErrorMetadata>::metadata()
        }
    }
    impl<T: Trait> Module<T> {
        /// Ensure that the DID is registered and this is not a replayed payload by checking the equality
        /// with stored block number when the DID was last modified.
        fn ensure_did_registered_and_payload_fresh(
            did: &Did,
            last_modified_in_block: BlockNumber,
        ) -> Result<KeyDetail, DispatchError> {
            let (current_key_detail, last_modified) = Self::get_key_detail(did)?;
            {
                if !(last_modified == T::BlockNumber::from(last_modified_in_block)) {
                    {
                        return Err(Error::<T>::DifferentBlockNumber.into());
                    };
                }
            };
            Ok(current_key_detail)
        }
        /// Get the key detail and the block number of last modification of the given DID.
        /// It assumes that the DID has only 1 public key which is true for now but will change later.
        /// This function will then be modified to indicate which key(s) of the DID should be used.
        /// If DID is not registered an error is raised.
        pub fn get_key_detail(did: &Did) -> Result<(KeyDetail, T::BlockNumber), DispatchError> {
            if let Some((current_key_detail, last_modified)) = Dids::<T>::get(did) {
                Ok((current_key_detail, last_modified))
            } else {
                {
                    return Err(Error::<T>::DidDoesNotExist.into());
                }
            }
        }
        /// Verify given signature on the given message with the given DID's only public key.
        /// It assumes that the DID has only 1 public key which is true for now but will change later.
        /// This function will then be modified to indicate which key(s) of the DID should be used.
        /// If DID is not registered an error is raised.
        /// This function is intended to be used by other modules as well to check the signature from a DID.
        pub fn verify_sig_from_did(
            signature: &DidSignature,
            message: &[u8],
            did: &Did,
        ) -> Result<bool, DispatchError> {
            let (current_key_detail, _) = Self::get_key_detail(did)?;
            Self::verify_sig_with_public_key(signature, message, &current_key_detail.public_key)
        }
        /// Verify given signature on the given message with given public key
        pub fn verify_sig_with_public_key(
            signature: &DidSignature,
            message: &[u8],
            public_key: &PublicKey,
        ) -> Result<bool, DispatchError> {
            Ok(match public_key {
                PublicKey::Sr25519(bytes) => {
                    let signature = sr25519::Signature::try_from(
                        signature
                            .as_sr25519_sig_bytes()
                            .map_err(|_| Error::<T>::InvalidSigType)?,
                    )
                    .map_err(|_| Error::<T>::InvalidSig)?;
                    let pk = sr25519::Public(bytes.value);
                    signature.verify(message, &pk)
                }
                PublicKey::Ed25519(bytes) => {
                    let signature = ed25519::Signature::try_from(
                        signature
                            .as_ed25519_sig_bytes()
                            .map_err(|_| Error::<T>::InvalidSigType)?,
                    )
                    .map_err(|_| Error::<T>::InvalidSig)?;
                    let pk = ed25519::Public(bytes.value);
                    signature.verify(message, &pk)
                }
                PublicKey::Secp256k1(bytes) => {
                    let signature = ecdsa::Signature::try_from(
                        signature
                            .as_secp256k1_sig_bytes()
                            .map_err(|_| Error::<T>::InvalidSigType)?,
                    )
                    .map_err(|_| Error::<T>::InvalidSig)?;
                    let pk = ecdsa::Public::from_raw(bytes.value);
                    signature.verify(message, &pk)
                }
            })
        }
    }
}
pub mod master {
    //! Simulates a multisig root account.
    //!
    //! Each substrate runtime module declares a "Call" enum. The "Call" enum is created by the
    //! `decl_module!` macro. Let's call that enum `module::Call`. Each `module::Call` is a reified
    //! invocation of one of the modules methods. The `module::Call` for this:
    //!
    //! ```
    //! # mod a {
    //! # use frame_support::{decl_module, dispatch::DispatchResult};
    //! # type Foo = ();
    //! # type Bar = ();
    //! # trait Trait: frame_system::Config {}
    //! decl_module! {
    //!     pub struct Module<T: Trait> for enum Call where origin: T::Origin {
    //!         #[weight = 100_000]
    //!         pub fn frob(origin, foo: Foo) -> DispatchResult { Ok(()) }
    //!         #[weight = 100_000]
    //!         pub fn unfrob(origin, foo: Foo, bar: Bar) -> DispatchResult { Ok(()) }
    //!     }
    //! }
    //! # }
    //! ```
    //!
    //! looks something like this:
    //!
    //! ```
    //! # type Foo = ();
    //! # type Bar = ();
    //! enum Call {
    //!     frob(Foo),
    //!     unfrob(Foo, Bar),
    //! }
    //! ```
    //!
    //! The `construct_runtime!` macro assembles the calls from all the included modules into a
    //! single "super call". The name of this enum is also "Call", but let's refer to it as
    //! `runtime::Call`. A `runtime::Call` looks something like this:
    //!
    //! ```
    //! # mod module1 { pub type Call = (); }
    //! # mod module2 { pub type Call = (); }
    //! # mod module3 { pub type Call = (); }
    //! enum Call {
    //!    Module1(module1::Call),
    //!    Module2(module2::Call),
    //!    Module3(module3::Call),
    //! }
    //! ```
    //!
    //! This module allows members of the group called Master to "vote" on a `runtime::Call` (a
    //! proposal) using cryptographic signatures. The votes, along with the proposed `runtime::Call`
    //! are submitted in a single transaction. If enough valid votes endorse the proposal, the proposal
    //! is run as root. If the running the proposal as root succeeds, a new round of voting is started.
    //!
    //! Each member of Master is idenitified by their dock DID.
    //!
    //! This module implement partial replay protection to prevent unauthorized resubmission of votes
    //! from previous rounds.
    use crate::{
        did::{Did, DidSignature},
        revoke::get_weight_for_pauth,
        StateChange,
    };
    use alloc::{
        boxed::Box,
        collections::{BTreeMap, BTreeSet},
        vec::Vec,
    };
    use codec::{Decode, Encode};
    use core::default::Default;
    use frame_support::dispatch::PostDispatchInfo;
    use frame_support::{
        decl_error, decl_event, decl_module, decl_storage,
        dispatch::{
            DispatchError, DispatchErrorWithPostInfo, DispatchResult, DispatchResultWithPostInfo,
        },
        ensure,
        traits::{Get, UnfilteredDispatchable},
        weights::{GetDispatchInfo, Pays, RuntimeDbWeight, Weight},
        Parameter,
    };
    use frame_system::{self as system, ensure_root, ensure_signed};
    pub struct Payload {
        /// The serialized Call to be run as root.
        proposal: Vec<u8>,
        /// The round for which the vote is to be valid
        round_no: u64,
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for Payload {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                __codec_dest_edqy.push(&self.proposal);
                __codec_dest_edqy.push(&self.round_no);
            }
        }
        impl _parity_scale_codec::EncodeLike for Payload {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for Payload {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(Payload {
                    proposal: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Payload.proposal".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    round_no: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Payload.round_no".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Payload {
        #[inline]
        fn clone(&self) -> Payload {
            match *self {
                Payload {
                    proposal: ref __self_0_0,
                    round_no: ref __self_0_1,
                } => Payload {
                    proposal: ::core::clone::Clone::clone(&(*__self_0_0)),
                    round_no: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Payload {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Payload {
        #[inline]
        fn eq(&self, other: &Payload) -> bool {
            match *other {
                Payload {
                    proposal: ref __self_1_0,
                    round_no: ref __self_1_1,
                } => match *self {
                    Payload {
                        proposal: ref __self_0_0,
                        round_no: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Payload) -> bool {
            match *other {
                Payload {
                    proposal: ref __self_1_0,
                    round_no: ref __self_1_1,
                } => match *self {
                    Payload {
                        proposal: ref __self_0_0,
                        round_no: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Payload {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Payload {
                    proposal: ref __self_0_0,
                    round_no: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Payload");
                    let _ = debug_trait_builder.field("proposal", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("round_no", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    /// Proof of authorization by Master.
    pub type PMAuth = BTreeMap<Did, DidSignature>;
    pub struct Membership {
        pub members: BTreeSet<Did>,
        pub vote_requirement: u64,
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for Membership {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                __codec_dest_edqy.push(&self.members);
                __codec_dest_edqy.push(&self.vote_requirement);
            }
        }
        impl _parity_scale_codec::EncodeLike for Membership {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for Membership {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(Membership {
                    members: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Membership.members".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    vote_requirement: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err(
                                    "Error decoding field Membership.vote_requirement".into()
                                )
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Membership {
        #[inline]
        fn clone(&self) -> Membership {
            match *self {
                Membership {
                    members: ref __self_0_0,
                    vote_requirement: ref __self_0_1,
                } => Membership {
                    members: ::core::clone::Clone::clone(&(*__self_0_0)),
                    vote_requirement: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Membership {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Membership {
        #[inline]
        fn eq(&self, other: &Membership) -> bool {
            match *other {
                Membership {
                    members: ref __self_1_0,
                    vote_requirement: ref __self_1_1,
                } => match *self {
                    Membership {
                        members: ref __self_0_0,
                        vote_requirement: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Membership) -> bool {
            match *other {
                Membership {
                    members: ref __self_1_0,
                    vote_requirement: ref __self_1_1,
                } => match *self {
                    Membership {
                        members: ref __self_0_0,
                        vote_requirement: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Membership {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Membership {
                    members: ref __self_0_0,
                    vote_requirement: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Membership");
                    let _ = debug_trait_builder.field("members", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("vote_requirement", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Membership {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Membership",
                    false as usize + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "members",
                    &self.members,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "vote_requirement",
                    &self.vote_requirement,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Membership {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "members" => _serde::__private::Ok(__Field::__field0),
                            "vote_requirement" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"members" => _serde::__private::Ok(__Field::__field0),
                            b"vote_requirement" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Membership>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Membership;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Membership")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            BTreeSet<Did>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Membership with 2 elements",
                                ));
                            }
                        };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Membership with 2 elements",
                                        ),
                                    );
                                }
                            };
                        _serde::__private::Ok(Membership {
                            members: __field0,
                            vote_requirement: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<BTreeSet<Did>> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "members",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<BTreeSet<Did>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "vote_requirement",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u64>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("members") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("vote_requirement") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Membership {
                            members: __field0,
                            vote_requirement: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["members", "vote_requirement"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Membership",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Membership>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl Default for Membership {
        fn default() -> Self {
            Membership {
                members: BTreeSet::new(),
                vote_requirement: 1,
            }
        }
    }
    const MIN_WEIGHT: Weight = 10_000;
    /// Minimum weight for master's extrinsics. Considers cost of signature verification and update to round no
    fn get_min_weight_for_execute(auth: &PMAuth, db_weights: RuntimeDbWeight) -> Weight {
        MIN_WEIGHT + get_weight_for_pauth(&auth, db_weights) + db_weights.reads_writes(1, 1)
    }
    pub trait Trait: system::Config + crate::did::Trait
    where
        <Self as system::Config>::AccountId: Ord,
    {
        type Event: From<Event<Self>> + Into<<Self as system::Config>::Event>;
        /// The dispatchable that master may call as Root. It is possible to use another type here, but
        /// it's expected that your runtime::Call will be used.
        /// Master's call should bypass any filter.
        type Call: Parameter + UnfilteredDispatchable<Origin = Self::Origin> + GetDispatchInfo;
    }
    use self::sp_api_hidden_includes_decl_storage::hidden_include::{
        StorageValue as _, StorageMap as _, StorageDoubleMap as _, StoragePrefixedMap as _,
        IterableStorageMap as _, IterableStorageDoubleMap as _,
    };
    #[doc(hidden)]
    mod sp_api_hidden_includes_decl_storage {
        pub extern crate frame_support as hidden_include;
    }
    trait Store {
        type Members;
        type Round;
    }
    impl<T: Trait + 'static> Store for Module<T> {
        type Members = Members;
        type Round = Round;
    }
    impl<T: Trait + 'static> Module<T> {}
    #[doc(hidden)]
    pub struct __GetByteStructMembers<T>(
        pub  self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<
            (T),
        >,
    );
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_Members:
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<
            self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>,
        > =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl<T: Trait> self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
        for __GetByteStructMembers<T>
    {
        fn default_byte(
            &self,
        ) -> self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>
        {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_Members
                .get_or_init(|| {
                    let def_val: Membership = Default::default();
                    <Membership as Encode>::encode(&def_val)
                })
                .clone()
        }
    }
    unsafe impl<T: Trait> Send for __GetByteStructMembers<T> {}
    unsafe impl<T: Trait> Sync for __GetByteStructMembers<T> {}
    #[doc(hidden)]
    pub struct __GetByteStructRound<T>(
        pub  self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<
            (T),
        >,
    );
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_Round:
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<
            self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>,
        > =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl<T: Trait> self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
        for __GetByteStructRound<T>
    {
        fn default_byte(
            &self,
        ) -> self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>
        {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_Round
                .get_or_init(|| {
                    let def_val: u64 = Default::default();
                    <u64 as Encode>::encode(&def_val)
                })
                .clone()
        }
    }
    unsafe impl<T: Trait> Send for __GetByteStructRound<T> {}
    unsafe impl<T: Trait> Sync for __GetByteStructRound<T> {}
    impl<T: Trait + 'static> Module<T> {
        #[doc(hidden)]
        pub fn storage_metadata(
        ) -> self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageMetadata
        {
            self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageMetadata { prefix : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("Master") , entries : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (& [self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryMetadata { name : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("Members") , modifier : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryModifier :: Default , ty : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryType :: Plain (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("Membership")) , default : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DefaultByteGetter (& __GetByteStructMembers :: < T > (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_std :: marker :: PhantomData))) , documentation : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (& []) , } , self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryMetadata { name : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("Round") , modifier : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryModifier :: Default , ty : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryType :: Plain (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("u64")) , default : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DefaultByteGetter (& __GetByteStructRound :: < T > (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_std :: marker :: PhantomData))) , documentation : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (& []) , }] [..]) , }
        }
    }
    /// Hidden instance generated to be internally used when module is used without
    /// instance.
    #[doc(hidden)]
    pub struct __InherentHiddenInstance;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for __InherentHiddenInstance {
        #[inline]
        fn clone(&self) -> __InherentHiddenInstance {
            match *self {
                __InherentHiddenInstance => __InherentHiddenInstance,
            }
        }
    }
    impl ::core::marker::StructuralEq for __InherentHiddenInstance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for __InherentHiddenInstance {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    impl ::core::marker::StructuralPartialEq for __InherentHiddenInstance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for __InherentHiddenInstance {
        #[inline]
        fn eq(&self, other: &__InherentHiddenInstance) -> bool {
            match *other {
                __InherentHiddenInstance => match *self {
                    __InherentHiddenInstance => true,
                },
            }
        }
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for __InherentHiddenInstance {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
            }
        }
        impl _parity_scale_codec::EncodeLike for __InherentHiddenInstance {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for __InherentHiddenInstance {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(__InherentHiddenInstance)
            }
        }
    };
    impl core::fmt::Debug for __InherentHiddenInstance {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("__InherentHiddenInstance").finish()
        }
    }
    impl self::sp_api_hidden_includes_decl_storage::hidden_include::traits::Instance
        for __InherentHiddenInstance
    {
        const PREFIX: &'static str = "Master";
    }
    /// Genesis config for the module, allow to build genesis storage.
    #[cfg(feature = "std")]
    #[serde(rename_all = "camelCase")]
    #[serde(deny_unknown_fields)]
    #[serde(bound(
        serialize = "Membership : self :: sp_api_hidden_includes_decl_storage :: hidden_include::serde::Serialize, "
    ))]
    #[serde(bound(
        deserialize = "Membership : self :: sp_api_hidden_includes_decl_storage :: hidden_include::serde::de::DeserializeOwned, "
    ))]
    pub struct GenesisConfig {
        pub members: Membership,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for GenesisConfig
        where
            Membership: self::sp_api_hidden_includes_decl_storage::hidden_include::serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "GenesisConfig",
                    false as usize + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "members",
                    &self.members,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl < 'de > _serde :: Deserialize < 'de > for GenesisConfig where Membership : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: serde :: de :: DeserializeOwned { fn deserialize < __D > (__deserializer : __D) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { # [allow (non_camel_case_types)] enum __Field { __field0 , } struct __FieldVisitor ; impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "field identifier") } fn visit_u64 < __E > (self , __value : u64) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , _ => _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "field index 0 <= i < 1")) , } } fn visit_str < __E > (self , __value : & str) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { "members" => _serde :: __private :: Ok (__Field :: __field0) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_field (__value , FIELDS)) } } } fn visit_bytes < __E > (self , __value : & [u8]) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { b"members" => _serde :: __private :: Ok (__Field :: __field0) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_field (__value , FIELDS)) } } } } impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor) } } struct __Visitor < 'de > where Membership : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: serde :: de :: DeserializeOwned { marker : _serde :: __private :: PhantomData < GenesisConfig > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > where Membership : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: serde :: de :: DeserializeOwned { type Value = GenesisConfig ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "struct GenesisConfig") } # [inline] fn visit_seq < __A > (self , mut __seq : __A) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > { let __field0 = match match _serde :: de :: SeqAccess :: next_element :: < Membership > (& mut __seq) { _serde :: __private :: Ok (__val) => __val , _serde :: __private :: Err (__err) => { return _serde :: __private :: Err (__err) ; } } { _serde :: __private :: Some (__value) => __value , _serde :: __private :: None => { return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct GenesisConfig with 1 element")) ; } } ; _serde :: __private :: Ok (GenesisConfig { members : __field0 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > { let mut __field0 : _serde :: __private :: Option < Membership > = _serde :: __private :: None ; while let _serde :: __private :: Some (__key) = match _serde :: de :: MapAccess :: next_key :: < __Field > (& mut __map) { _serde :: __private :: Ok (__val) => __val , _serde :: __private :: Err (__err) => { return _serde :: __private :: Err (__err) ; } } { match __key { __Field :: __field0 => { if _serde :: __private :: Option :: is_some (& __field0) { return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("members")) ; } __field0 = _serde :: __private :: Some (match _serde :: de :: MapAccess :: next_value :: < Membership > (& mut __map) { _serde :: __private :: Ok (__val) => __val , _serde :: __private :: Err (__err) => { return _serde :: __private :: Err (__err) ; } }) ; } } } let __field0 = match __field0 { _serde :: __private :: Some (__field0) => __field0 , _serde :: __private :: None => match _serde :: __private :: de :: missing_field ("members") { _serde :: __private :: Ok (__val) => __val , _serde :: __private :: Err (__err) => { return _serde :: __private :: Err (__err) ; } } , } ; _serde :: __private :: Ok (GenesisConfig { members : __field0 , }) } } const FIELDS : & 'static [& 'static str] = & ["members"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "GenesisConfig" , FIELDS , __Visitor { marker : _serde :: __private :: PhantomData :: < GenesisConfig > , lifetime : _serde :: __private :: PhantomData , }) } }
    };
    #[cfg(feature = "std")]
    impl Default for GenesisConfig {
        fn default() -> Self {
            GenesisConfig {
                members: Default::default(),
            }
        }
    }
    #[cfg(feature = "std")]
    impl GenesisConfig {
        /// Build the storage for this module.
        pub fn build_storage(
            &self,
        ) -> std::result::Result<
            self::sp_api_hidden_includes_decl_storage::hidden_include::sp_runtime::Storage,
            String,
        > {
            let mut storage = Default::default();
            self.assimilate_storage(&mut storage)?;
            Ok(storage)
        }
        /// Assimilate the storage for this module into pre-existing overlays.
        pub fn assimilate_storage(
            &self,
            storage : & mut self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_runtime :: Storage,
        ) -> std::result::Result<(), String> {
            self :: sp_api_hidden_includes_decl_storage :: hidden_include :: BasicExternalities :: execute_with_storage (storage , | | { let extra_genesis_builder : fn (& Self) = | slef : & Self | { if true { if ! (slef . members . vote_requirement != 0) { :: core :: panicking :: panic ("assertion failed: slef.members.vote_requirement != 0") } ; } ; if true { if ! (slef . members . vote_requirement <= slef . members . members . len () as u64) { :: core :: panicking :: panic ("assertion failed: slef.members.vote_requirement <= slef.members.members.len() as u64") } ; } ; Members :: set (slef . members . clone ()) ; } ; extra_genesis_builder (self) ; Ok (()) })
        }
    }
    #[cfg(feature = "std")]
    impl < T : Trait , __GeneratedInstance : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_runtime :: BuildModuleGenesisStorage < T , __GeneratedInstance > for GenesisConfig { fn build_module_genesis_storage (& self , storage : & mut self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_runtime :: Storage) -> std :: result :: Result < () , String > { self . assimilate_storage :: < > (storage) } }
    pub struct Members(
        self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<()>,
    );
    impl
        self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageValue<
            Membership,
        > for Members
    {
        type Query = Membership;
        fn module_prefix() -> &'static [u8] {
            < __InherentHiddenInstance as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > :: PREFIX . as_bytes ()
        }
        fn storage_prefix() -> &'static [u8] {
            b"Members"
        }
        fn from_optional_value_to_query(v: Option<Membership>) -> Self::Query {
            v.unwrap_or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query) -> Option<Membership> {
            Some(v)
        }
    }
    pub struct Round(
        self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<()>,
    );
    impl
        self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageValue<
            u64,
        > for Round
    {
        type Query = u64;
        fn module_prefix() -> &'static [u8] {
            < __InherentHiddenInstance as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > :: PREFIX . as_bytes ()
        }
        fn storage_prefix() -> &'static [u8] {
            b"Round"
        }
        fn from_optional_value_to_query(v: Option<u64>) -> Self::Query {
            v.unwrap_or_else(|| Default::default())
        }
        fn from_query_to_optional_value(v: Self::Query) -> Option<u64> {
            Some(v)
        }
    }
    pub enum MasterError<T: Trait> {
        #[doc(hidden)]
        __Ignore(
            ::frame_support::sp_std::marker::PhantomData<(T,)>,
            ::frame_support::Never,
        ),
        /// The account used to submit this vote is not a member of Master.
        NotMember,
        /// This proposal does not yet have enough votes to be executed.
        InsufficientVotes,
        /// One of the signatures provided is invalid.
        /// Hint: Is everyone voting for the current round?
        BadSig,
        /// A vote requirement of 0 would allow unresricted sudo access.
        ZeroVoteRequirement,
        /// There aren't enough members to satisfy that vote requirement.
        VoteRequirementTooHigh,
    }
    impl<T: Trait> ::frame_support::sp_std::fmt::Debug for MasterError<T> {
        fn fmt(
            &self,
            f: &mut ::frame_support::sp_std::fmt::Formatter<'_>,
        ) -> ::frame_support::sp_std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl<T: Trait> MasterError<T> {
        fn as_u8(&self) -> u8 {
            match self {
                MasterError::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"`__Ignore` can never be constructed",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                MasterError::NotMember => 0,
                MasterError::InsufficientVotes => 0 + 1,
                MasterError::BadSig => 0 + 1 + 1,
                MasterError::ZeroVoteRequirement => 0 + 1 + 1 + 1,
                MasterError::VoteRequirementTooHigh => 0 + 1 + 1 + 1 + 1,
            }
        }
        fn as_str(&self) -> &'static str {
            match self {
                Self::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"`__Ignore` can never be constructed",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                MasterError::NotMember => "NotMember",
                MasterError::InsufficientVotes => "InsufficientVotes",
                MasterError::BadSig => "BadSig",
                MasterError::ZeroVoteRequirement => "ZeroVoteRequirement",
                MasterError::VoteRequirementTooHigh => "VoteRequirementTooHigh",
            }
        }
    }
    impl<T: Trait> From<MasterError<T>> for &'static str {
        fn from(err: MasterError<T>) -> &'static str {
            err.as_str()
        }
    }
    impl<T: Trait> From<MasterError<T>> for ::frame_support::sp_runtime::DispatchError {
        fn from(err: MasterError<T>) -> Self {
            let index = <T::PalletInfo as ::frame_support::traits::PalletInfo>::index::<Module<T>>()
                .expect("Every active module has an index in the runtime; qed")
                as u8;
            ::frame_support::sp_runtime::DispatchError::Module {
                index,
                error: err.as_u8(),
                message: Some(err.as_str()),
            }
        }
    }
    impl<T: Trait> ::frame_support::error::ModuleErrorMetadata for MasterError<T> {
        fn metadata() -> &'static [::frame_support::error::ErrorMetadata] {
            &[
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("NotMember"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" The account used to submit this vote is not a member of Master.",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("InsufficientVotes"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" This proposal does not yet have enough votes to be executed.",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("BadSig"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" One of the signatures provided is invalid.",
                        r" Hint: Is everyone voting for the current round?",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("ZeroVoteRequirement"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" A vote requirement of 0 would allow unresricted sudo access.",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("VoteRequirementTooHigh"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" There aren't enough members to satisfy that vote requirement.",
                    ]),
                },
            ]
        }
    }
    /// [`RawEvent`] specialized for the configuration [`Config`]
    ///
    /// [`RawEvent`]: enum.RawEvent.html
    /// [`Config`]: trait.Config.html
    pub type Event<T> = RawEvent<<T as Trait>::Call>;
    /// Events for this module.
    ///
    pub enum RawEvent<Call> {
        /// A proposal succeeded and was executed. The dids listed are the members whose votes were
        /// used as proof of authorization. The executed call is provided.
        Executed(Vec<Did>, Box<Call>),
        /// The membership of Master has changed.
        UnderNewOwnership,
        /// A proposal failed to execute
        ExecutionFailed(Vec<Did>, Box<Call>, DispatchError),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<Call: ::core::clone::Clone> ::core::clone::Clone for RawEvent<Call> {
        #[inline]
        fn clone(&self) -> RawEvent<Call> {
            match (&*self,) {
                (&RawEvent::Executed(ref __self_0, ref __self_1),) => RawEvent::Executed(
                    ::core::clone::Clone::clone(&(*__self_0)),
                    ::core::clone::Clone::clone(&(*__self_1)),
                ),
                (&RawEvent::UnderNewOwnership,) => RawEvent::UnderNewOwnership,
                (&RawEvent::ExecutionFailed(ref __self_0, ref __self_1, ref __self_2),) => {
                    RawEvent::ExecutionFailed(
                        ::core::clone::Clone::clone(&(*__self_0)),
                        ::core::clone::Clone::clone(&(*__self_1)),
                        ::core::clone::Clone::clone(&(*__self_2)),
                    )
                }
            }
        }
    }
    impl<Call> ::core::marker::StructuralPartialEq for RawEvent<Call> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<Call: ::core::cmp::PartialEq> ::core::cmp::PartialEq for RawEvent<Call> {
        #[inline]
        fn eq(&self, other: &RawEvent<Call>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &RawEvent::Executed(ref __self_0, ref __self_1),
                            &RawEvent::Executed(ref __arg_1_0, ref __arg_1_1),
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        (
                            &RawEvent::ExecutionFailed(ref __self_0, ref __self_1, ref __self_2),
                            &RawEvent::ExecutionFailed(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),
                        ) => {
                            (*__self_0) == (*__arg_1_0)
                                && (*__self_1) == (*__arg_1_1)
                                && (*__self_2) == (*__arg_1_2)
                        }
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &RawEvent<Call>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &RawEvent::Executed(ref __self_0, ref __self_1),
                            &RawEvent::Executed(ref __arg_1_0, ref __arg_1_1),
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        (
                            &RawEvent::ExecutionFailed(ref __self_0, ref __self_1, ref __self_2),
                            &RawEvent::ExecutionFailed(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),
                        ) => {
                            (*__self_0) != (*__arg_1_0)
                                || (*__self_1) != (*__arg_1_1)
                                || (*__self_2) != (*__arg_1_2)
                        }
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<Call> ::core::marker::StructuralEq for RawEvent<Call> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<Call: ::core::cmp::Eq> ::core::cmp::Eq for RawEvent<Call> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<Vec<Did>>;
                let _: ::core::cmp::AssertParamIsEq<Box<Call>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<Did>>;
                let _: ::core::cmp::AssertParamIsEq<Box<Call>>;
                let _: ::core::cmp::AssertParamIsEq<DispatchError>;
            }
        }
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl<Call> _parity_scale_codec::Encode for RawEvent<Call>
        where
            Box<Call>: _parity_scale_codec::Encode,
            Box<Call>: _parity_scale_codec::Encode,
            Box<Call>: _parity_scale_codec::Encode,
            Box<Call>: _parity_scale_codec::Encode,
        {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    RawEvent::Executed(ref aa, ref ba) => {
                        __codec_dest_edqy.push_byte(0usize as u8);
                        __codec_dest_edqy.push(aa);
                        __codec_dest_edqy.push(ba);
                    }
                    RawEvent::UnderNewOwnership => {
                        __codec_dest_edqy.push_byte(1usize as u8);
                    }
                    RawEvent::ExecutionFailed(ref aa, ref ba, ref ca) => {
                        __codec_dest_edqy.push_byte(2usize as u8);
                        __codec_dest_edqy.push(aa);
                        __codec_dest_edqy.push(ba);
                        __codec_dest_edqy.push(ca);
                    }
                    _ => (),
                }
            }
        }
        impl<Call> _parity_scale_codec::EncodeLike for RawEvent<Call>
        where
            Box<Call>: _parity_scale_codec::Encode,
            Box<Call>: _parity_scale_codec::Encode,
            Box<Call>: _parity_scale_codec::Encode,
            Box<Call>: _parity_scale_codec::Encode,
        {
        }
    };
    const _: () =
        {
            #[allow(unknown_lints)]
            #[allow(rust_2018_idioms)]
            extern crate codec as _parity_scale_codec;
            impl<Call> _parity_scale_codec::Decode for RawEvent<Call>
            where
                Box<Call>: _parity_scale_codec::Decode,
                Box<Call>: _parity_scale_codec::Decode,
                Box<Call>: _parity_scale_codec::Decode,
                Box<Call>: _parity_scale_codec::Decode,
            {
                fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                    __codec_input_edqy: &mut __CodecInputEdqy,
                ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                    match __codec_input_edqy.read_byte()? {
                        __codec_x_edqy if __codec_x_edqy == 0usize as u8 => Ok(RawEvent::Executed(
                            {
                                let __codec_res_edqy =
                                    _parity_scale_codec::Decode::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    Err(_) => {
                                        return Err(
                                            "Error decoding field RawEvent :: Executed.0".into()
                                        )
                                    }
                                    Ok(__codec_res_edqy) => __codec_res_edqy,
                                }
                            },
                            {
                                let __codec_res_edqy =
                                    _parity_scale_codec::Decode::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    Err(_) => {
                                        return Err(
                                            "Error decoding field RawEvent :: Executed.1".into()
                                        )
                                    }
                                    Ok(__codec_res_edqy) => __codec_res_edqy,
                                }
                            },
                        )),
                        __codec_x_edqy if __codec_x_edqy == 1usize as u8 => {
                            Ok(RawEvent::UnderNewOwnership)
                        }
                        __codec_x_edqy if __codec_x_edqy == 2usize as u8 => {
                            Ok(RawEvent::ExecutionFailed(
                                {
                                    let __codec_res_edqy =
                                        _parity_scale_codec::Decode::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        Err(_) => return Err(
                                            "Error decoding field RawEvent :: ExecutionFailed.0"
                                                .into(),
                                        ),
                                        Ok(__codec_res_edqy) => __codec_res_edqy,
                                    }
                                },
                                {
                                    let __codec_res_edqy =
                                        _parity_scale_codec::Decode::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        Err(_) => return Err(
                                            "Error decoding field RawEvent :: ExecutionFailed.1"
                                                .into(),
                                        ),
                                        Ok(__codec_res_edqy) => __codec_res_edqy,
                                    }
                                },
                                {
                                    let __codec_res_edqy =
                                        _parity_scale_codec::Decode::decode(__codec_input_edqy);
                                    match __codec_res_edqy {
                                        Err(_) => return Err(
                                            "Error decoding field RawEvent :: ExecutionFailed.2"
                                                .into(),
                                        ),
                                        Ok(__codec_res_edqy) => __codec_res_edqy,
                                    }
                                },
                            ))
                        }
                        _ => Err("No such variant in enum RawEvent".into()),
                    }
                }
            }
        };
    impl<Call> core::fmt::Debug for RawEvent<Call>
    where
        Call: core::fmt::Debug,
    {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            match self {
                Self::Executed(ref a0, ref a1) => fmt
                    .debug_tuple("RawEvent::Executed")
                    .field(a0)
                    .field(a1)
                    .finish(),
                Self::UnderNewOwnership => fmt.debug_tuple("RawEvent::UnderNewOwnership").finish(),
                Self::ExecutionFailed(ref a0, ref a1, ref a2) => fmt
                    .debug_tuple("RawEvent::ExecutionFailed")
                    .field(a0)
                    .field(a1)
                    .field(a2)
                    .finish(),
                _ => Ok(()),
            }
        }
    }
    impl<Call> From<RawEvent<Call>> for () {
        fn from(_: RawEvent<Call>) -> () {
            ()
        }
    }
    impl<Call> RawEvent<Call> {
        #[allow(dead_code)]
        #[doc(hidden)]
        pub fn metadata() -> &'static [::frame_support::event::EventMetadata] {
            &[
                ::frame_support::event::EventMetadata {
                    name: ::frame_support::event::DecodeDifferent::Encode("Executed"),
                    arguments: ::frame_support::event::DecodeDifferent::Encode(&[
                        "Vec<Did>",
                        "Box<Call>",
                    ]),
                    documentation: ::frame_support::event::DecodeDifferent::Encode(&[
                        r" A proposal succeeded and was executed. The dids listed are the members whose votes were",
                        r" used as proof of authorization. The executed call is provided.",
                    ]),
                },
                ::frame_support::event::EventMetadata {
                    name: ::frame_support::event::DecodeDifferent::Encode("UnderNewOwnership"),
                    arguments: ::frame_support::event::DecodeDifferent::Encode(&[]),
                    documentation: ::frame_support::event::DecodeDifferent::Encode(&[
                        r" The membership of Master has changed.",
                    ]),
                },
                ::frame_support::event::EventMetadata {
                    name: ::frame_support::event::DecodeDifferent::Encode("ExecutionFailed"),
                    arguments: ::frame_support::event::DecodeDifferent::Encode(&[
                        "Vec<Did>",
                        "Box<Call>",
                        "DispatchError",
                    ]),
                    documentation: ::frame_support::event::DecodeDifferent::Encode(&[
                        r" A proposal failed to execute",
                    ]),
                },
            ]
        }
    }
    pub struct Module<T: Trait>(::frame_support::sp_std::marker::PhantomData<(T,)>);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::clone::Clone + Trait> ::core::clone::Clone for Module<T> {
        #[inline]
        fn clone(&self) -> Module<T> {
            match *self {
                Module(ref __self_0_0) => Module(::core::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::marker::Copy + Trait> ::core::marker::Copy for Module<T> {}
    impl<T: Trait> ::core::marker::StructuralPartialEq for Module<T> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::cmp::PartialEq + Trait> ::core::cmp::PartialEq for Module<T> {
        #[inline]
        fn eq(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) => match *self {
                    Module(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) => match *self {
                    Module(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl<T: Trait> ::core::marker::StructuralEq for Module<T> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::cmp::Eq + Trait> ::core::cmp::Eq for Module<T> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<
                    ::frame_support::sp_std::marker::PhantomData<(T,)>,
                >;
            }
        }
    }
    impl<T: Trait> core::fmt::Debug for Module<T>
    where
        T: core::fmt::Debug,
    {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("Module").field(&self.0).finish()
        }
    }
    impl<T: frame_system::Config + Trait>
        ::frame_support::traits::OnInitialize<<T as frame_system::Config>::BlockNumber>
        for Module<T>
    {
    }
    impl<T: Trait> ::frame_support::traits::OnRuntimeUpgrade for Module<T> {
        fn on_runtime_upgrade() -> ::frame_support::dispatch::Weight {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "on_runtime_upgrade",
                            "core_mods::master",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/master.rs"),
                            Some(179u32),
                            Some("core_mods::master"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
            .put_into_storage::<<T as frame_system::Config>::PalletInfo, Self>();
            <<T as frame_system::Config>::DbWeight as ::frame_support::traits::Get<_>>::get()
                .writes(1)
        }
    }
    impl<T: frame_system::Config + Trait>
        ::frame_support::traits::OnFinalize<<T as frame_system::Config>::BlockNumber>
        for Module<T>
    {
    }
    impl<T: frame_system::Config + Trait>
        ::frame_support::traits::OffchainWorker<<T as frame_system::Config>::BlockNumber>
        for Module<T>
    {
    }
    impl<T: Trait> Module<T> {
        /// Deposits an event using `frame_system::Module::deposit_event`.
        fn deposit_event(event: impl Into<<T as Trait>::Event>) {
            <frame_system::Module<T>>::deposit_event(event.into())
        }
    }
    #[cfg(feature = "std")]
    impl<T: Trait> ::frame_support::traits::IntegrityTest for Module<T> {}
    /// Can also be called using [`Call`].
    ///
    /// [`Call`]: enum.Call.html
    impl<T: Trait> Module<T> {
        /// Execute a proposal that has received enough votes. The proposal is a serialized Call.
        /// This function can be called by anyone, even someone who is not a member of Master.
        ///
        /// After a successful execution, the round number is increased.
        ///
        /// NOTE: Calling this function will bypass origin filters.
        pub fn execute(
            origin: T::Origin,
            proposal: Box<<T as Trait>::Call>,
            auth: PMAuth,
        ) -> DispatchResultWithPostInfo {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "execute",
                            "core_mods::master",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/master.rs"),
                            Some(179u32),
                            Some("core_mods::master"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            Module::<T>::execute_(origin, proposal, auth, None)
        }
        /// Does the same job as `execute` dispatchable but does not inherit the weight of the
        /// `Call` its wrapping but expects the caller to provide it
        ///
        /// NOTE: Calling this function will bypass origin filters.
        pub fn execute_unchecked_weight(
            origin: T::Origin,
            proposal: Box<<T as Trait>::Call>,
            auth: PMAuth,
            _weight: Weight,
        ) -> DispatchResultWithPostInfo {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "execute_unchecked_weight",
                            "core_mods::master",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/master.rs"),
                            Some(179u32),
                            Some("core_mods::master"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            let weight = get_min_weight_for_execute(&auth, T::DbWeight::get()) + _weight;
            Module::<T>::execute_(origin, proposal, auth, Some(weight))
        }
        /// Root-only. Sets the members and vote requirement for master. Increases the round number
        /// and removes the votes for the previous round.
        ///
        /// Since as a group members of master have root access, they will be able to call this
        /// function.
        ///
        /// A vote requirement of zero is not allowed and will result in an error.
        /// A vote requirement larger than the size of the member list is not allowed and will
        /// result in an error.
        ///
        /// NOTE: Calling this function will bypass origin filters.
        pub fn set_members(
            origin: T::Origin,
            membership: Membership,
        ) -> DispatchResultWithPostInfo {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "set_members",
                            "core_mods::master",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/master.rs"),
                            Some(179u32),
                            Some("core_mods::master"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            Module::<T>::set_members_(origin, membership)?;
            Ok(Pays::No.into())
        }
    }
    /// Dispatchable calls.
    ///
    /// Each variant of this enum maps to a dispatchable function from the associated module.
    pub enum Call<T: Trait> {
        #[doc(hidden)]
        #[codec(skip)]
        __PhantomItem(
            ::frame_support::sp_std::marker::PhantomData<(T,)>,
            ::frame_support::Never,
        ),
        #[allow(non_camel_case_types)]
        /// Execute a proposal that has received enough votes. The proposal is a serialized Call.
        /// This function can be called by anyone, even someone who is not a member of Master.
        ///
        /// After a successful execution, the round number is increased.
        execute(Box<<T as Trait>::Call>, PMAuth),
        #[allow(non_camel_case_types)]
        /// Does the same job as `execute` dispatchable but does not inherit the weight of the
        /// `Call` its wrapping but expects the caller to provide it
        execute_unchecked_weight(Box<<T as Trait>::Call>, PMAuth, Weight),
        #[allow(non_camel_case_types)]
        /// Root-only. Sets the members and vote requirement for master. Increases the round number
        /// and removes the votes for the previous round.
        ///
        /// Since as a group members of master have root access, they will be able to call this
        /// function.
        ///
        /// A vote requirement of zero is not allowed and will result in an error.
        /// A vote requirement larger than the size of the member list is not allowed and will
        /// result in an error.
        set_members(Membership),
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl<T: Trait> _parity_scale_codec::Encode for Call<T>
        where
            Box<<T as Trait>::Call>: _parity_scale_codec::Encode,
            Box<<T as Trait>::Call>: _parity_scale_codec::Encode,
            Box<<T as Trait>::Call>: _parity_scale_codec::Encode,
            Box<<T as Trait>::Call>: _parity_scale_codec::Encode,
        {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    Call::execute(ref aa, ref ba) => {
                        __codec_dest_edqy.push_byte(0usize as u8);
                        __codec_dest_edqy.push(aa);
                        __codec_dest_edqy.push(ba);
                    }
                    Call::execute_unchecked_weight(ref aa, ref ba, ref ca) => {
                        __codec_dest_edqy.push_byte(1usize as u8);
                        __codec_dest_edqy.push(aa);
                        __codec_dest_edqy.push(ba);
                        __codec_dest_edqy.push(ca);
                    }
                    Call::set_members(ref aa) => {
                        __codec_dest_edqy.push_byte(2usize as u8);
                        __codec_dest_edqy.push(aa);
                    }
                    _ => (),
                }
            }
        }
        impl<T: Trait> _parity_scale_codec::EncodeLike for Call<T>
        where
            Box<<T as Trait>::Call>: _parity_scale_codec::Encode,
            Box<<T as Trait>::Call>: _parity_scale_codec::Encode,
            Box<<T as Trait>::Call>: _parity_scale_codec::Encode,
            Box<<T as Trait>::Call>: _parity_scale_codec::Encode,
        {
        }
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl<T: Trait> _parity_scale_codec::Decode for Call<T>
        where
            Box<<T as Trait>::Call>: _parity_scale_codec::Decode,
            Box<<T as Trait>::Call>: _parity_scale_codec::Decode,
            Box<<T as Trait>::Call>: _parity_scale_codec::Decode,
            Box<<T as Trait>::Call>: _parity_scale_codec::Decode,
        {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                match __codec_input_edqy.read_byte()? {
                    __codec_x_edqy if __codec_x_edqy == 0usize as u8 => Ok(Call::execute(
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err("Error decoding field Call :: execute.0".into())
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err("Error decoding field Call :: execute.1".into())
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    )),
                    __codec_x_edqy if __codec_x_edqy == 1usize as u8 => {
                        Ok(Call::execute_unchecked_weight(
                            {
                                let __codec_res_edqy =
                                    _parity_scale_codec::Decode::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    Err(_) => return Err(
                                        "Error decoding field Call :: execute_unchecked_weight.0"
                                            .into(),
                                    ),
                                    Ok(__codec_res_edqy) => __codec_res_edqy,
                                }
                            },
                            {
                                let __codec_res_edqy =
                                    _parity_scale_codec::Decode::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    Err(_) => return Err(
                                        "Error decoding field Call :: execute_unchecked_weight.1"
                                            .into(),
                                    ),
                                    Ok(__codec_res_edqy) => __codec_res_edqy,
                                }
                            },
                            {
                                let __codec_res_edqy =
                                    _parity_scale_codec::Decode::decode(__codec_input_edqy);
                                match __codec_res_edqy {
                                    Err(_) => return Err(
                                        "Error decoding field Call :: execute_unchecked_weight.2"
                                            .into(),
                                    ),
                                    Ok(__codec_res_edqy) => __codec_res_edqy,
                                }
                            },
                        ))
                    }
                    __codec_x_edqy if __codec_x_edqy == 2usize as u8 => Ok(Call::set_members({
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err("Error decoding field Call :: set_members.0".into())
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    })),
                    _ => Err("No such variant in enum Call".into()),
                }
            }
        }
    };
    impl<T: Trait> ::frame_support::dispatch::GetDispatchInfo for Call<T> {
        fn get_dispatch_info(&self) -> ::frame_support::dispatch::DispatchInfo {
            match *self {
                Call::execute(ref proposal, ref auth) => {
                    let base_weight = (
                        get_min_weight_for_execute(&auth, T::DbWeight::get())
                            + proposal.get_dispatch_info().weight,
                        proposal.get_dispatch_info().class,
                        proposal.get_dispatch_info().pays_fee,
                    );
                    let weight = <dyn ::frame_support::dispatch::WeighData<(
                        &Box<<T as Trait>::Call>,
                        &PMAuth,
                    )>>::weigh_data(&base_weight, (proposal, auth));
                    let class = <dyn ::frame_support::dispatch::ClassifyDispatch<(
                        &Box<<T as Trait>::Call>,
                        &PMAuth,
                    )>>::classify_dispatch(
                        &base_weight, (proposal, auth)
                    );
                    let pays_fee = <dyn ::frame_support::dispatch::PaysFee<(
                        &Box<<T as Trait>::Call>,
                        &PMAuth,
                    )>>::pays_fee(&base_weight, (proposal, auth));
                    ::frame_support::dispatch::DispatchInfo {
                        weight,
                        class,
                        pays_fee,
                    }
                }
                Call::execute_unchecked_weight(ref proposal, ref auth, ref _weight) => {
                    let base_weight = (
                        get_min_weight_for_execute(&auth, T::DbWeight::get()) + _weight,
                        proposal.get_dispatch_info().class,
                        proposal.get_dispatch_info().pays_fee,
                    );
                    let weight = <dyn ::frame_support::dispatch::WeighData<(
                        &Box<<T as Trait>::Call>,
                        &PMAuth,
                        &Weight,
                    )>>::weigh_data(
                        &base_weight, (proposal, auth, _weight)
                    );
                    let class = <dyn ::frame_support::dispatch::ClassifyDispatch<(
                        &Box<<T as Trait>::Call>,
                        &PMAuth,
                        &Weight,
                    )>>::classify_dispatch(
                        &base_weight, (proposal, auth, _weight)
                    );
                    let pays_fee = <dyn ::frame_support::dispatch::PaysFee<(
                        &Box<<T as Trait>::Call>,
                        &PMAuth,
                        &Weight,
                    )>>::pays_fee(
                        &base_weight, (proposal, auth, _weight)
                    );
                    ::frame_support::dispatch::DispatchInfo {
                        weight,
                        class,
                        pays_fee,
                    }
                }
                Call::set_members(ref membership) => {
                    let base_weight = MIN_WEIGHT + T::DbWeight::get().reads_writes(1, 2);
                    let weight =
                        <dyn ::frame_support::dispatch::WeighData<(&Membership,)>>::weigh_data(
                            &base_weight,
                            (membership,),
                        );
                    let class = < dyn :: frame_support :: dispatch :: ClassifyDispatch < (& Membership ,) > > :: classify_dispatch (& base_weight , (membership ,)) ;
                    let pays_fee =
                        <dyn ::frame_support::dispatch::PaysFee<(&Membership,)>>::pays_fee(
                            &base_weight,
                            (membership,),
                        );
                    ::frame_support::dispatch::DispatchInfo {
                        weight,
                        class,
                        pays_fee,
                    }
                }
                Call::__PhantomItem(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__PhantomItem should never be used.",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::GetCallName for Call<T> {
        fn get_call_name(&self) -> &'static str {
            match *self {
                Call::execute(ref proposal, ref auth) => {
                    let _ = (proposal, auth);
                    "execute"
                }
                Call::execute_unchecked_weight(ref proposal, ref auth, ref _weight) => {
                    let _ = (proposal, auth, _weight);
                    "execute_unchecked_weight"
                }
                Call::set_members(ref membership) => {
                    let _ = (membership);
                    "set_members"
                }
                Call::__PhantomItem(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__PhantomItem should never be used.",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
        fn get_call_names() -> &'static [&'static str] {
            &["execute", "execute_unchecked_weight", "set_members"]
        }
    }
    pub use ::frame_support::traits::GetPalletVersion as _;
    impl<T: Trait> ::frame_support::traits::GetPalletVersion for Module<T> {
        fn current_version() -> ::frame_support::traits::PalletVersion {
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
        }
        fn storage_version() -> Option<::frame_support::traits::PalletVersion> {
            let key = ::frame_support::traits::PalletVersion::storage_key::<
                <T as frame_system::Config>::PalletInfo,
                Self,
            >()
            .expect("Every active pallet has a name in the runtime; qed");
            ::frame_support::storage::unhashed::get(&key)
        }
    }
    impl<T: Trait> ::frame_support::traits::OnGenesis for Module<T> {
        fn on_genesis() {
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
            .put_into_storage::<<T as frame_system::Config>::PalletInfo, Self>();
        }
    }
    impl<T: Trait> ::frame_support::dispatch::Clone for Call<T> {
        fn clone(&self) -> Self {
            match *self {
                Call::execute(ref proposal, ref auth) => {
                    Call::execute((*proposal).clone(), (*auth).clone())
                }
                Call::execute_unchecked_weight(ref proposal, ref auth, ref _weight) => {
                    Call::execute_unchecked_weight(
                        (*proposal).clone(),
                        (*auth).clone(),
                        (*_weight).clone(),
                    )
                }
                Call::set_members(ref membership) => Call::set_members((*membership).clone()),
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::PartialEq for Call<T> {
        fn eq(&self, _other: &Self) -> bool {
            match *self {
                Call::execute(ref proposal, ref auth) => {
                    let self_params = (proposal, auth);
                    if let Call::execute(ref proposal, ref auth) = *_other {
                        self_params == (proposal, auth)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                ::core::panicking::panic("internal error: entered unreachable code")
                            }
                            _ => false,
                        }
                    }
                }
                Call::execute_unchecked_weight(ref proposal, ref auth, ref _weight) => {
                    let self_params = (proposal, auth, _weight);
                    if let Call::execute_unchecked_weight(ref proposal, ref auth, ref _weight) =
                        *_other
                    {
                        self_params == (proposal, auth, _weight)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                ::core::panicking::panic("internal error: entered unreachable code")
                            }
                            _ => false,
                        }
                    }
                }
                Call::set_members(ref membership) => {
                    let self_params = (membership,);
                    if let Call::set_members(ref membership) = *_other {
                        self_params == (membership,)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                ::core::panicking::panic("internal error: entered unreachable code")
                            }
                            _ => false,
                        }
                    }
                }
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::Eq for Call<T> {}
    impl<T: Trait> ::frame_support::dispatch::fmt::Debug for Call<T> {
        fn fmt(
            &self,
            _f: &mut ::frame_support::dispatch::fmt::Formatter,
        ) -> ::frame_support::dispatch::result::Result<(), ::frame_support::dispatch::fmt::Error>
        {
            match *self {
                Call::execute(ref proposal, ref auth) => {
                    _f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["", ""],
                        &match (&"execute", &(proposal.clone(), auth.clone())) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                            ],
                        },
                    ))
                }
                Call::execute_unchecked_weight(ref proposal, ref auth, ref _weight) => _f
                    .write_fmt(::core::fmt::Arguments::new_v1(
                        &["", ""],
                        &match (
                            &"execute_unchecked_weight",
                            &(proposal.clone(), auth.clone(), _weight.clone()),
                        ) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                            ],
                        },
                    )),
                Call::set_members(ref membership) => _f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", ""],
                    &match (&"set_members", &(membership.clone(),)) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                        ],
                    },
                )),
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
    }
    impl<T: Trait> ::frame_support::traits::UnfilteredDispatchable for Call<T> {
        type Origin = T::Origin;
        fn dispatch_bypass_filter(
            self,
            _origin: Self::Origin,
        ) -> ::frame_support::dispatch::DispatchResultWithPostInfo {
            match self {
                Call::execute(proposal, auth) => <Module<T>>::execute(_origin, proposal, auth)
                    .map(Into::into)
                    .map_err(Into::into),
                Call::execute_unchecked_weight(proposal, auth, _weight) => {
                    <Module<T>>::execute_unchecked_weight(_origin, proposal, auth, _weight)
                        .map(Into::into)
                        .map_err(Into::into)
                }
                Call::set_members(membership) => <Module<T>>::set_members(_origin, membership)
                    .map(Into::into)
                    .map_err(Into::into),
                Call::__PhantomItem(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__PhantomItem should never be used.",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::Callable<T> for Module<T> {
        type Call = Call<T>;
    }
    impl<T: Trait> Module<T> {
        #[doc(hidden)]
        #[allow(dead_code)]
        pub fn call_functions() -> &'static [::frame_support::dispatch::FunctionMetadata] {
            &[
                ::frame_support::dispatch::FunctionMetadata {
                    name: ::frame_support::dispatch::DecodeDifferent::Encode("execute"),
                    arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("proposal"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                                "Box<<T as Trait>::Call>",
                            ),
                        },
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("auth"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode("PMAuth"),
                        },
                    ]),
                    documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        r" Execute a proposal that has received enough votes. The proposal is a serialized Call.",
                        r" This function can be called by anyone, even someone who is not a member of Master.",
                        r"",
                        r" After a successful execution, the round number is increased.",
                    ]),
                },
                ::frame_support::dispatch::FunctionMetadata {
                    name: ::frame_support::dispatch::DecodeDifferent::Encode(
                        "execute_unchecked_weight",
                    ),
                    arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("proposal"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                                "Box<<T as Trait>::Call>",
                            ),
                        },
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("auth"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode("PMAuth"),
                        },
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("_weight"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode("Weight"),
                        },
                    ]),
                    documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        r" Does the same job as `execute` dispatchable but does not inherit the weight of the",
                        r" `Call` its wrapping but expects the caller to provide it",
                    ]),
                },
                ::frame_support::dispatch::FunctionMetadata {
                    name: ::frame_support::dispatch::DecodeDifferent::Encode("set_members"),
                    arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("membership"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode("Membership"),
                        },
                    ]),
                    documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        r" Root-only. Sets the members and vote requirement for master. Increases the round number",
                        r" and removes the votes for the previous round.",
                        r"",
                        r" Since as a group members of master have root access, they will be able to call this",
                        r" function.",
                        r"",
                        r" A vote requirement of zero is not allowed and will result in an error.",
                        r" A vote requirement larger than the size of the member list is not allowed and will",
                        r" result in an error.",
                    ]),
                },
            ]
        }
    }
    impl<T: 'static + Trait> Module<T> {
        #[doc(hidden)]
        #[allow(dead_code)]
        pub fn module_constants_metadata(
        ) -> &'static [::frame_support::dispatch::ModuleConstantMetadata] {
            &[]
        }
    }
    impl<T: Trait> ::frame_support::dispatch::ModuleErrorMetadata for Module<T> {
        fn metadata() -> &'static [::frame_support::dispatch::ErrorMetadata] {
            <MasterError<T> as ::frame_support::dispatch::ModuleErrorMetadata>::metadata()
        }
    }
    impl<T: Trait> Module<T> {
        /// Execute a call as Root origin after verifying signatures in `auth`. If `given_weight` is None,
        /// then it computes the weight by considering the cost of signature verification and cost of
        /// executing the call. If `given_weight` has a value then that is considered as weight.
        /// Note: The following can be misused to do recursive calls as the proposal can itself be call
        /// leading to `execute_` which will keep the cycle going. This can be prevented by incrementing
        /// the round no before dispatching the call in `proposal` and if the call throws error then
        /// decrementing the round no before returning the error.
        /// However, since this call is made by entities that not adversarial, the behavior is not dangerous
        /// in this case
        fn execute_(
            origin: T::Origin,
            proposal: Box<<T as Trait>::Call>,
            auth: PMAuth,
            given_weight: Option<Weight>,
        ) -> DispatchResultWithPostInfo {
            ensure_signed(origin)?;
            let membership = Members::get();
            {
                if !(auth.len() as u64 >= membership.vote_requirement) {
                    {
                        return Err(MasterError::<T>::InsufficientVotes.into());
                    };
                }
            };
            {
                if !auth.keys().all(|k| membership.members.contains(k)) {
                    {
                        return Err(MasterError::<T>::NotMember.into());
                    };
                }
            };
            let payload = StateChange::MasterVote(Payload {
                proposal: proposal.encode(),
                round_no: Round::get(),
            })
            .encode();
            for (did, sig) in auth.iter() {
                let valid = crate::did::Module::<T>::verify_sig_from_did(sig, &payload, did)?;
                {
                    if !valid {
                        {
                            return Err(MasterError::<T>::BadSig.into());
                        };
                    }
                };
            }
            let dispatch_result = proposal
                .clone()
                .dispatch_bypass_filter(system::RawOrigin::Root.into());
            Round::mutate(|round| {
                *round += 1;
            });
            let dispatch_decl_weight = proposal.get_dispatch_info().weight;
            let authors = auth.keys().cloned().collect();
            let actual_weight = move |post_info: PostDispatchInfo| {
                given_weight.or_else(|| {
                    Some(
                        post_info
                            .actual_weight
                            .unwrap_or_else(|| dispatch_decl_weight)
                            + get_min_weight_for_execute(&auth, T::DbWeight::get()),
                    )
                })
            };
            match dispatch_result {
                Ok(post_dispatch_info) => {
                    Self::deposit_event(RawEvent::Executed(authors, proposal));
                    Ok(PostDispatchInfo {
                        actual_weight: actual_weight(post_dispatch_info),
                        pays_fee: post_dispatch_info.pays_fee,
                    })
                }
                Err(e) => {
                    Self::deposit_event(RawEvent::ExecutionFailed(authors, proposal, e.error));
                    Err(DispatchErrorWithPostInfo {
                        post_info: PostDispatchInfo {
                            actual_weight: actual_weight(e.post_info),
                            pays_fee: e.post_info.pays_fee,
                        },
                        error: e.error,
                    })
                }
            }
        }
        fn set_members_(origin: T::Origin, membership: Membership) -> DispatchResult {
            ensure_root(origin)?;
            {
                if !(membership.vote_requirement != 0) {
                    {
                        return Err(MasterError::<T>::ZeroVoteRequirement.into());
                    };
                }
            };
            {
                if !(membership.vote_requirement <= membership.members.len() as u64) {
                    {
                        return Err(MasterError::<T>::VoteRequirementTooHigh.into());
                    };
                }
            };
            Members::set(membership);
            Round::mutate(|round| {
                *round += 1;
            });
            Self::deposit_event(RawEvent::UnderNewOwnership);
            Ok(())
        }
    }
}
pub mod revoke {
    use crate as dock;
    use crate::did::{self, Did, DidSignature, ED25519_WEIGHT, SECP256K1_WEIGHT, SR25519_WEIGHT};
    use alloc::collections::{BTreeMap, BTreeSet};
    use codec::{Decode, Encode};
    use frame_support::{
        decl_error, decl_module, decl_storage,
        dispatch::{DispatchError, DispatchResult},
        ensure,
        traits::Get,
        weights::{RuntimeDbWeight, Weight},
    };
    use frame_system::{self as system, ensure_signed};
    /// Points to an on-chain revocation registry.
    pub type RegistryId = [u8; 32];
    /// Points to a revocation which may or may not exist in a registry.
    pub type RevokeId = [u8; 32];
    /// Proof of authorization to modify a registry.
    pub type PAuth = BTreeMap<Did, DidSignature>;
    /// Authorization logic for a registry.
    pub enum Policy {
        /// Set of dids allowed to modify a registry.
        OneOf(BTreeSet<Did>),
    }
    impl ::core::marker::StructuralPartialEq for Policy {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Policy {
        #[inline]
        fn eq(&self, other: &Policy) -> bool {
            match (&*self, &*other) {
                (&Policy::OneOf(ref __self_0), &Policy::OneOf(ref __arg_1_0)) => {
                    (*__self_0) == (*__arg_1_0)
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Policy) -> bool {
            match (&*self, &*other) {
                (&Policy::OneOf(ref __self_0), &Policy::OneOf(ref __arg_1_0)) => {
                    (*__self_0) != (*__arg_1_0)
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for Policy {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Policy {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<BTreeSet<Did>>;
            }
        }
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for Policy {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    Policy::OneOf(ref aa) => {
                        __codec_dest_edqy.push_byte(0usize as u8);
                        __codec_dest_edqy.push(aa);
                    }
                    _ => (),
                }
            }
        }
        impl _parity_scale_codec::EncodeLike for Policy {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for Policy {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                match __codec_input_edqy.read_byte()? {
                    __codec_x_edqy if __codec_x_edqy == 0usize as u8 => Ok(Policy::OneOf({
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Policy :: OneOf.0".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    })),
                    _ => Err("No such variant in enum Policy".into()),
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Policy {
        #[inline]
        fn clone(&self) -> Policy {
            match (&*self,) {
                (&Policy::OneOf(ref __self_0),) => {
                    Policy::OneOf(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Policy {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Policy::OneOf(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("OneOf");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Policy {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Policy::OneOf(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Policy",
                        0u32,
                        "OneOf",
                        __field0,
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Policy {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 1",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "OneOf" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"OneOf" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Policy>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Policy;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum Policy")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<BTreeSet<Did>>(
                                    __variant,
                                ),
                                Policy::OneOf,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["OneOf"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Policy",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Policy>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl Policy {
        /// Check for user error in the construction of self.
        /// if self is invalid, return `false`, else return `true`.
        fn valid(&self) -> bool {
            match self {
                Self::OneOf(controllers) => !controllers.is_empty(),
            }
        }
    }
    /// Metadata about a revocation scope.
    pub struct Registry {
        /// Who is allowed to update this registry.
        pub policy: Policy,
        /// true: credentials can be revoked, but not un-revoked
        /// false: credentials can be revoked and un-revoked
        pub add_only: bool,
    }
    impl ::core::marker::StructuralPartialEq for Registry {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Registry {
        #[inline]
        fn eq(&self, other: &Registry) -> bool {
            match *other {
                Registry {
                    policy: ref __self_1_0,
                    add_only: ref __self_1_1,
                } => match *self {
                    Registry {
                        policy: ref __self_0_0,
                        add_only: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Registry) -> bool {
            match *other {
                Registry {
                    policy: ref __self_1_0,
                    add_only: ref __self_1_1,
                } => match *self {
                    Registry {
                        policy: ref __self_0_0,
                        add_only: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::core::marker::StructuralEq for Registry {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Registry {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<Policy>;
                let _: ::core::cmp::AssertParamIsEq<bool>;
            }
        }
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for Registry {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                __codec_dest_edqy.push(&self.policy);
                __codec_dest_edqy.push(&self.add_only);
            }
        }
        impl _parity_scale_codec::EncodeLike for Registry {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for Registry {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(Registry {
                    policy: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Registry.policy".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    add_only: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Registry.add_only".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Registry {
        #[inline]
        fn clone(&self) -> Registry {
            match *self {
                Registry {
                    policy: ref __self_0_0,
                    add_only: ref __self_0_1,
                } => Registry {
                    policy: ::core::clone::Clone::clone(&(*__self_0_0)),
                    add_only: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Registry {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Registry {
                    policy: ref __self_0_0,
                    add_only: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Registry");
                    let _ = debug_trait_builder.field("policy", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("add_only", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Registry {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Registry",
                    false as usize + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "policy",
                    &self.policy,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "add_only",
                    &self.add_only,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Registry {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "policy" => _serde::__private::Ok(__Field::__field0),
                            "add_only" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"policy" => _serde::__private::Ok(__Field::__field0),
                            b"add_only" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Registry>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Registry;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Registry")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<Policy>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Registry with 2 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Registry with 2 elements",
                                        ),
                                    );
                                }
                            };
                        _serde::__private::Ok(Registry {
                            policy: __field0,
                            add_only: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Policy> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "policy",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Policy>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "add_only",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<bool>(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("policy") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("add_only") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Registry {
                            policy: __field0,
                            add_only: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["policy", "add_only"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Registry",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Registry>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Command to create a set of revocations withing a registry.
    /// Creation of revocations is idempotent; creating a revocation that already exists is allowed,
    /// but has no effect.
    pub struct Revoke {
        /// The registry on which to operate
        pub registry_id: RegistryId,
        /// Credential ids which will be revoked
        pub revoke_ids: BTreeSet<RevokeId>,
        /// For replay protection
        pub last_modified: crate::BlockNumber,
    }
    impl ::core::marker::StructuralPartialEq for Revoke {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Revoke {
        #[inline]
        fn eq(&self, other: &Revoke) -> bool {
            match *other {
                Revoke {
                    registry_id: ref __self_1_0,
                    revoke_ids: ref __self_1_1,
                    last_modified: ref __self_1_2,
                } => match *self {
                    Revoke {
                        registry_id: ref __self_0_0,
                        revoke_ids: ref __self_0_1,
                        last_modified: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Revoke) -> bool {
            match *other {
                Revoke {
                    registry_id: ref __self_1_0,
                    revoke_ids: ref __self_1_1,
                    last_modified: ref __self_1_2,
                } => match *self {
                    Revoke {
                        registry_id: ref __self_0_0,
                        revoke_ids: ref __self_0_1,
                        last_modified: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::core::marker::StructuralEq for Revoke {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Revoke {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<RegistryId>;
                let _: ::core::cmp::AssertParamIsEq<BTreeSet<RevokeId>>;
                let _: ::core::cmp::AssertParamIsEq<crate::BlockNumber>;
            }
        }
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for Revoke {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                __codec_dest_edqy.push(&self.registry_id);
                __codec_dest_edqy.push(&self.revoke_ids);
                __codec_dest_edqy.push(&self.last_modified);
            }
        }
        impl _parity_scale_codec::EncodeLike for Revoke {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for Revoke {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(Revoke {
                    registry_id: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Revoke.registry_id".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    revoke_ids: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field Revoke.revoke_ids".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    last_modified: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err("Error decoding field Revoke.last_modified".into())
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Revoke {
        #[inline]
        fn clone(&self) -> Revoke {
            match *self {
                Revoke {
                    registry_id: ref __self_0_0,
                    revoke_ids: ref __self_0_1,
                    last_modified: ref __self_0_2,
                } => Revoke {
                    registry_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    revoke_ids: ::core::clone::Clone::clone(&(*__self_0_1)),
                    last_modified: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Revoke {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Revoke {
                    registry_id: ref __self_0_0,
                    revoke_ids: ref __self_0_1,
                    last_modified: ref __self_0_2,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Revoke");
                    let _ = debug_trait_builder.field("registry_id", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("revoke_ids", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("last_modified", &&(*__self_0_2));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Revoke {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Revoke",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "registry_id",
                    &self.registry_id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "revoke_ids",
                    &self.revoke_ids,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "last_modified",
                    &self.last_modified,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Revoke {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "registry_id" => _serde::__private::Ok(__Field::__field0),
                            "revoke_ids" => _serde::__private::Ok(__Field::__field1),
                            "last_modified" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"registry_id" => _serde::__private::Ok(__Field::__field0),
                            b"revoke_ids" => _serde::__private::Ok(__Field::__field1),
                            b"last_modified" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Revoke>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Revoke;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Revoke")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<RegistryId>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Revoke with 3 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            BTreeSet<RevokeId>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Revoke with 3 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            crate::BlockNumber,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct Revoke with 3 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(Revoke {
                            registry_id: __field0,
                            revoke_ids: __field1,
                            last_modified: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<RegistryId> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<BTreeSet<RevokeId>> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<crate::BlockNumber> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "registry_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<RegistryId>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "revoke_ids",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<BTreeSet<RevokeId>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "last_modified",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<crate::BlockNumber>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("registry_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("revoke_ids") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("last_modified") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Revoke {
                            registry_id: __field0,
                            revoke_ids: __field1,
                            last_modified: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] =
                    &["registry_id", "revoke_ids", "last_modified"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Revoke",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Revoke>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Command to remove a set of revocations within a registry.
    /// Removal of revocations is idempotent; removing a revocation that doesn't exists is allowed,
    /// but has no effect.
    pub struct UnRevoke {
        /// The registry on which to operate
        pub registry_id: RegistryId,
        /// Credential ids which will be revoked
        pub revoke_ids: BTreeSet<RevokeId>,
        /// For replay protection
        pub last_modified: crate::BlockNumber,
    }
    impl ::core::marker::StructuralPartialEq for UnRevoke {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for UnRevoke {
        #[inline]
        fn eq(&self, other: &UnRevoke) -> bool {
            match *other {
                UnRevoke {
                    registry_id: ref __self_1_0,
                    revoke_ids: ref __self_1_1,
                    last_modified: ref __self_1_2,
                } => match *self {
                    UnRevoke {
                        registry_id: ref __self_0_0,
                        revoke_ids: ref __self_0_1,
                        last_modified: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &UnRevoke) -> bool {
            match *other {
                UnRevoke {
                    registry_id: ref __self_1_0,
                    revoke_ids: ref __self_1_1,
                    last_modified: ref __self_1_2,
                } => match *self {
                    UnRevoke {
                        registry_id: ref __self_0_0,
                        revoke_ids: ref __self_0_1,
                        last_modified: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::core::marker::StructuralEq for UnRevoke {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for UnRevoke {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<RegistryId>;
                let _: ::core::cmp::AssertParamIsEq<BTreeSet<RevokeId>>;
                let _: ::core::cmp::AssertParamIsEq<crate::BlockNumber>;
            }
        }
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for UnRevoke {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                __codec_dest_edqy.push(&self.registry_id);
                __codec_dest_edqy.push(&self.revoke_ids);
                __codec_dest_edqy.push(&self.last_modified);
            }
        }
        impl _parity_scale_codec::EncodeLike for UnRevoke {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for UnRevoke {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(UnRevoke {
                    registry_id: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err("Error decoding field UnRevoke.registry_id".into())
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    revoke_ids: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => return Err("Error decoding field UnRevoke.revoke_ids".into()),
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    last_modified: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err("Error decoding field UnRevoke.last_modified".into())
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for UnRevoke {
        #[inline]
        fn clone(&self) -> UnRevoke {
            match *self {
                UnRevoke {
                    registry_id: ref __self_0_0,
                    revoke_ids: ref __self_0_1,
                    last_modified: ref __self_0_2,
                } => UnRevoke {
                    registry_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    revoke_ids: ::core::clone::Clone::clone(&(*__self_0_1)),
                    last_modified: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for UnRevoke {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                UnRevoke {
                    registry_id: ref __self_0_0,
                    revoke_ids: ref __self_0_1,
                    last_modified: ref __self_0_2,
                } => {
                    let mut debug_trait_builder = f.debug_struct("UnRevoke");
                    let _ = debug_trait_builder.field("registry_id", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("revoke_ids", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("last_modified", &&(*__self_0_2));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UnRevoke {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "UnRevoke",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "registry_id",
                    &self.registry_id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "revoke_ids",
                    &self.revoke_ids,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "last_modified",
                    &self.last_modified,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UnRevoke {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "registry_id" => _serde::__private::Ok(__Field::__field0),
                            "revoke_ids" => _serde::__private::Ok(__Field::__field1),
                            "last_modified" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"registry_id" => _serde::__private::Ok(__Field::__field0),
                            b"revoke_ids" => _serde::__private::Ok(__Field::__field1),
                            b"last_modified" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UnRevoke>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UnRevoke;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct UnRevoke")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<RegistryId>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct UnRevoke with 3 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            BTreeSet<RevokeId>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct UnRevoke with 3 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            crate::BlockNumber,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct UnRevoke with 3 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(UnRevoke {
                            registry_id: __field0,
                            revoke_ids: __field1,
                            last_modified: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<RegistryId> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<BTreeSet<RevokeId>> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<crate::BlockNumber> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "registry_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<RegistryId>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "revoke_ids",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<BTreeSet<RevokeId>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "last_modified",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<crate::BlockNumber>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("registry_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("revoke_ids") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("last_modified") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(UnRevoke {
                            registry_id: __field0,
                            revoke_ids: __field1,
                            last_modified: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] =
                    &["registry_id", "revoke_ids", "last_modified"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UnRevoke",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UnRevoke>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Command to remove an entire registy. Removes all revocations in the registry as well as
    /// registry metadata.
    pub struct RemoveRegistry {
        /// The registry on which to operate
        pub registry_id: RegistryId,
        /// For replay protection
        pub last_modified: crate::BlockNumber,
    }
    impl ::core::marker::StructuralPartialEq for RemoveRegistry {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for RemoveRegistry {
        #[inline]
        fn eq(&self, other: &RemoveRegistry) -> bool {
            match *other {
                RemoveRegistry {
                    registry_id: ref __self_1_0,
                    last_modified: ref __self_1_1,
                } => match *self {
                    RemoveRegistry {
                        registry_id: ref __self_0_0,
                        last_modified: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &RemoveRegistry) -> bool {
            match *other {
                RemoveRegistry {
                    registry_id: ref __self_1_0,
                    last_modified: ref __self_1_1,
                } => match *self {
                    RemoveRegistry {
                        registry_id: ref __self_0_0,
                        last_modified: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::core::marker::StructuralEq for RemoveRegistry {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for RemoveRegistry {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<RegistryId>;
                let _: ::core::cmp::AssertParamIsEq<crate::BlockNumber>;
            }
        }
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for RemoveRegistry {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                __codec_dest_edqy.push(&self.registry_id);
                __codec_dest_edqy.push(&self.last_modified);
            }
        }
        impl _parity_scale_codec::EncodeLike for RemoveRegistry {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for RemoveRegistry {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(RemoveRegistry {
                    registry_id: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err("Error decoding field RemoveRegistry.registry_id".into())
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                    last_modified: {
                        let __codec_res_edqy =
                            _parity_scale_codec::Decode::decode(__codec_input_edqy);
                        match __codec_res_edqy {
                            Err(_) => {
                                return Err(
                                    "Error decoding field RemoveRegistry.last_modified".into()
                                )
                            }
                            Ok(__codec_res_edqy) => __codec_res_edqy,
                        }
                    },
                })
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for RemoveRegistry {
        #[inline]
        fn clone(&self) -> RemoveRegistry {
            match *self {
                RemoveRegistry {
                    registry_id: ref __self_0_0,
                    last_modified: ref __self_0_1,
                } => RemoveRegistry {
                    registry_id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    last_modified: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for RemoveRegistry {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                RemoveRegistry {
                    registry_id: ref __self_0_0,
                    last_modified: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("RemoveRegistry");
                    let _ = debug_trait_builder.field("registry_id", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("last_modified", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for RemoveRegistry {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "RemoveRegistry",
                    false as usize + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "registry_id",
                    &self.registry_id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "last_modified",
                    &self.last_modified,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for RemoveRegistry {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "registry_id" => _serde::__private::Ok(__Field::__field0),
                            "last_modified" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"registry_id" => _serde::__private::Ok(__Field::__field0),
                            b"last_modified" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<RemoveRegistry>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = RemoveRegistry;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct RemoveRegistry",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<RegistryId>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct RemoveRegistry with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            crate::BlockNumber,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct RemoveRegistry with 2 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(RemoveRegistry {
                            registry_id: __field0,
                            last_modified: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<RegistryId> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<crate::BlockNumber> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "registry_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<RegistryId>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "last_modified",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<crate::BlockNumber>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("registry_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("last_modified") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(RemoveRegistry {
                            registry_id: __field0,
                            last_modified: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["registry_id", "last_modified"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "RemoveRegistry",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<RemoveRegistry>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Return counts of different signature types in given PAuth as 3-Tuple as (no. of Sr22519 sigs,
    /// no. of Ed25519 Sigs, no. of Secp256k1 sigs). Useful for weight calculation and thus the return
    /// type is in `Weight` but realistically, it should fit in a u8
    fn count_sig_types(auth: &PAuth) -> (Weight, Weight, Weight) {
        let mut sr = 0;
        let mut ed = 0;
        let mut secp = 0;
        for sig in auth.values() {
            match sig {
                DidSignature::Sr25519(_) => sr += 1,
                DidSignature::Ed25519(_) => ed += 1,
                DidSignature::Secp256k1(_) => secp += 1,
            }
        }
        (sr, ed, secp)
    }
    /// Computes weight of the given `PAuth`. Considers the no. and types of signatures and no. of reads. Disregards
    /// message size as messages are hashed giving the same output size and hashing itself is very cheap.
    /// The extrinsic using it might decide to consider adding some weight proportional to the message size.
    pub fn get_weight_for_pauth(auth: &PAuth, db_weights: RuntimeDbWeight) -> Weight {
        let (sr, ed, secp) = count_sig_types(auth);
        (db_weights.reads(auth.len() as u64)
            + (sr * SR25519_WEIGHT)
            + (ed * ED25519_WEIGHT)
            + (secp * SECP256K1_WEIGHT)) as Weight
    }
    pub trait Trait: system::Config + did::Trait {}
    /// Revocation Error
    pub enum RevErr<T: Trait> {
        #[doc(hidden)]
        __Ignore(
            ::frame_support::sp_std::marker::PhantomData<(T,)>,
            ::frame_support::Never,
        ),
        /// The authorization policy provided was illegal.
        InvalidPolicy,
        /// Proof of authorization does not meet policy requirements.
        NotAuthorized,
        /// A revocation registry with that name already exists.
        RegExists,
        /// A revocation registry with that name does not exist.
        NoReg,
        /// `last_modified` is incorrect. This is related to replay protection.
        DifferentBlockNumber,
        /// This registry is marked as add_only. Deletion of revocations is not allowed. Deletion of
        /// the registry is not allowed.
        AddOnly,
    }
    impl<T: Trait> ::frame_support::sp_std::fmt::Debug for RevErr<T> {
        fn fmt(
            &self,
            f: &mut ::frame_support::sp_std::fmt::Formatter<'_>,
        ) -> ::frame_support::sp_std::fmt::Result {
            f.write_str(self.as_str())
        }
    }
    impl<T: Trait> RevErr<T> {
        fn as_u8(&self) -> u8 {
            match self {
                RevErr::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"`__Ignore` can never be constructed",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                RevErr::InvalidPolicy => 0,
                RevErr::NotAuthorized => 0 + 1,
                RevErr::RegExists => 0 + 1 + 1,
                RevErr::NoReg => 0 + 1 + 1 + 1,
                RevErr::DifferentBlockNumber => 0 + 1 + 1 + 1 + 1,
                RevErr::AddOnly => 0 + 1 + 1 + 1 + 1 + 1,
            }
        }
        fn as_str(&self) -> &'static str {
            match self {
                Self::__Ignore(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"`__Ignore` can never be constructed",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                RevErr::InvalidPolicy => "InvalidPolicy",
                RevErr::NotAuthorized => "NotAuthorized",
                RevErr::RegExists => "RegExists",
                RevErr::NoReg => "NoReg",
                RevErr::DifferentBlockNumber => "DifferentBlockNumber",
                RevErr::AddOnly => "AddOnly",
            }
        }
    }
    impl<T: Trait> From<RevErr<T>> for &'static str {
        fn from(err: RevErr<T>) -> &'static str {
            err.as_str()
        }
    }
    impl<T: Trait> From<RevErr<T>> for ::frame_support::sp_runtime::DispatchError {
        fn from(err: RevErr<T>) -> Self {
            let index = <T::PalletInfo as ::frame_support::traits::PalletInfo>::index::<Module<T>>()
                .expect("Every active module has an index in the runtime; qed")
                as u8;
            ::frame_support::sp_runtime::DispatchError::Module {
                index,
                error: err.as_u8(),
                message: Some(err.as_str()),
            }
        }
    }
    impl<T: Trait> ::frame_support::error::ModuleErrorMetadata for RevErr<T> {
        fn metadata() -> &'static [::frame_support::error::ErrorMetadata] {
            &[
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("InvalidPolicy"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" The authorization policy provided was illegal.",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("NotAuthorized"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" Proof of authorization does not meet policy requirements.",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("RegExists"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" A revocation registry with that name already exists.",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("NoReg"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" A revocation registry with that name does not exist.",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("DifferentBlockNumber"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" `last_modified` is incorrect. This is related to replay protection.",
                    ]),
                },
                ::frame_support::error::ErrorMetadata {
                    name: ::frame_support::error::DecodeDifferent::Encode("AddOnly"),
                    documentation: ::frame_support::error::DecodeDifferent::Encode(&[
                        r" This registry is marked as add_only. Deletion of revocations is not allowed. Deletion of",
                        r" the registry is not allowed.",
                    ]),
                },
            ]
        }
    }
    use self::sp_api_hidden_includes_decl_storage::hidden_include::{
        StorageValue as _, StorageMap as _, StorageDoubleMap as _, StoragePrefixedMap as _,
        IterableStorageMap as _, IterableStorageDoubleMap as _,
    };
    #[doc(hidden)]
    mod sp_api_hidden_includes_decl_storage {
        pub extern crate frame_support as hidden_include;
    }
    trait Store {
        type Registries;
        type Revocations;
    }
    impl<T: Trait + 'static> Store for Module<T> {
        type Registries = Registries<T>;
        type Revocations = Revocations;
    }
    impl<T: Trait + 'static> Module<T> {
        /// Registry metadata
        pub fn get_revocation_registry<
            K: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<
                dock::revoke::RegistryId,
            >,
        >(
            key: K,
        ) -> Option<(dock::revoke::Registry, T::BlockNumber)> {
            < Registries < T > as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: storage :: StorageMap < dock :: revoke :: RegistryId , (dock :: revoke :: Registry , T :: BlockNumber) > > :: get (key)
        }
        pub fn get_revocation_status<KArg1, KArg2>(k1: KArg1, k2: KArg2) -> Option<()>
        where
            KArg1: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<
                dock::revoke::RegistryId,
            >,
            KArg2: self::sp_api_hidden_includes_decl_storage::hidden_include::codec::EncodeLike<
                dock::revoke::RevokeId,
            >,
        {
            < Revocations < > as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: storage :: StorageDoubleMap < dock :: revoke :: RegistryId , dock :: revoke :: RevokeId , () > > :: get (k1 , k2)
        }
    }
    #[doc(hidden)]
    pub struct __GetByteStructRegistries<T>(
        pub  self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<
            (T),
        >,
    );
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_Registries:
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<
            self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>,
        > =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl<T: Trait> self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
        for __GetByteStructRegistries<T>
    {
        fn default_byte(
            &self,
        ) -> self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>
        {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_Registries
                .get_or_init(|| {
                    let def_val: Option<(dock::revoke::Registry, T::BlockNumber)> =
                        Default::default();
                    <Option<(dock::revoke::Registry, T::BlockNumber)> as Encode>::encode(&def_val)
                })
                .clone()
        }
    }
    unsafe impl<T: Trait> Send for __GetByteStructRegistries<T> {}
    unsafe impl<T: Trait> Sync for __GetByteStructRegistries<T> {}
    #[doc(hidden)]
    pub struct __GetByteStructRevocations<T>(
        pub  self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<
            (T),
        >,
    );
    #[cfg(feature = "std")]
    #[allow(non_upper_case_globals)]
    static __CACHE_GET_BYTE_STRUCT_Revocations:
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell<
            self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>,
        > =
        self::sp_api_hidden_includes_decl_storage::hidden_include::once_cell::sync::OnceCell::new();
    #[cfg(feature = "std")]
    impl<T: Trait> self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::DefaultByte
        for __GetByteStructRevocations<T>
    {
        fn default_byte(
            &self,
        ) -> self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::vec::Vec<u8>
        {
            use self::sp_api_hidden_includes_decl_storage::hidden_include::codec::Encode;
            __CACHE_GET_BYTE_STRUCT_Revocations
                .get_or_init(|| {
                    let def_val: Option<()> = Default::default();
                    <Option<()> as Encode>::encode(&def_val)
                })
                .clone()
        }
    }
    unsafe impl<T: Trait> Send for __GetByteStructRevocations<T> {}
    unsafe impl<T: Trait> Sync for __GetByteStructRevocations<T> {}
    impl<T: Trait + 'static> Module<T> {
        #[doc(hidden)]
        pub fn storage_metadata(
        ) -> self::sp_api_hidden_includes_decl_storage::hidden_include::metadata::StorageMetadata
        {
            self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageMetadata { prefix : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("Revoke") , entries : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (& [self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryMetadata { name : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("Registries") , modifier : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryModifier :: Optional , ty : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryType :: Map { hasher : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageHasher :: Blake2_128Concat , key : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("dock::revoke::RegistryId") , value : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("(dock::revoke::Registry, T::BlockNumber)") , unused : false , } , default : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DefaultByteGetter (& __GetByteStructRegistries :: < T > (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_std :: marker :: PhantomData))) , documentation : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (& [" Registry metadata"]) , } , self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryMetadata { name : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("Revocations") , modifier : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryModifier :: Optional , ty : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageEntryType :: DoubleMap { hasher : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageHasher :: Blake2_128Concat , key1 : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("dock::revoke::RegistryId") , key2 : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("dock::revoke::RevokeId") , value : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode ("()") , key2_hasher : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: StorageHasher :: Blake2_256 , } , default : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DefaultByteGetter (& __GetByteStructRevocations :: < T > (self :: sp_api_hidden_includes_decl_storage :: hidden_include :: sp_std :: marker :: PhantomData))) , documentation : self :: sp_api_hidden_includes_decl_storage :: hidden_include :: metadata :: DecodeDifferent :: Encode (& [" The single global revocation set"]) , }] [..]) , }
        }
    }
    /// Hidden instance generated to be internally used when module is used without
    /// instance.
    #[doc(hidden)]
    pub struct __InherentHiddenInstance;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for __InherentHiddenInstance {
        #[inline]
        fn clone(&self) -> __InherentHiddenInstance {
            match *self {
                __InherentHiddenInstance => __InherentHiddenInstance,
            }
        }
    }
    impl ::core::marker::StructuralEq for __InherentHiddenInstance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for __InherentHiddenInstance {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    impl ::core::marker::StructuralPartialEq for __InherentHiddenInstance {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for __InherentHiddenInstance {
        #[inline]
        fn eq(&self, other: &__InherentHiddenInstance) -> bool {
            match *other {
                __InherentHiddenInstance => match *self {
                    __InherentHiddenInstance => true,
                },
            }
        }
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Encode for __InherentHiddenInstance {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
            }
        }
        impl _parity_scale_codec::EncodeLike for __InherentHiddenInstance {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl _parity_scale_codec::Decode for __InherentHiddenInstance {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                Ok(__InherentHiddenInstance)
            }
        }
    };
    impl core::fmt::Debug for __InherentHiddenInstance {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("__InherentHiddenInstance").finish()
        }
    }
    impl self::sp_api_hidden_includes_decl_storage::hidden_include::traits::Instance
        for __InherentHiddenInstance
    {
        const PREFIX: &'static str = "Revoke";
    }
    /// Registry metadata
    struct Registries<T: Trait>(
        self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<
                (T,),
            >,
    );
    impl<T: Trait>
        self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StoragePrefixedMap<(
            dock::revoke::Registry,
            T::BlockNumber,
        )> for Registries<T>
    {
        fn module_prefix() -> &'static [u8] {
            < __InherentHiddenInstance as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > :: PREFIX . as_bytes ()
        }
        fn storage_prefix() -> &'static [u8] {
            b"Registries"
        }
    }
    impl<T: Trait>
        self::sp_api_hidden_includes_decl_storage::hidden_include::storage::generator::StorageMap<
            dock::revoke::RegistryId,
            (dock::revoke::Registry, T::BlockNumber),
        > for Registries<T>
    {
        type Query = Option<(dock::revoke::Registry, T::BlockNumber)>;
        type Hasher = self::sp_api_hidden_includes_decl_storage::hidden_include::Blake2_128Concat;
        fn module_prefix() -> &'static [u8] {
            < __InherentHiddenInstance as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > :: PREFIX . as_bytes ()
        }
        fn storage_prefix() -> &'static [u8] {
            b"Registries"
        }
        fn from_optional_value_to_query(
            v: Option<(dock::revoke::Registry, T::BlockNumber)>,
        ) -> Self::Query {
            v.or_else(|| Default::default())
        }
        fn from_query_to_optional_value(
            v: Self::Query,
        ) -> Option<(dock::revoke::Registry, T::BlockNumber)> {
            v
        }
    }
    /// The single global revocation set
    struct Revocations(
        self::sp_api_hidden_includes_decl_storage::hidden_include::sp_std::marker::PhantomData<()>,
    );
    impl self::sp_api_hidden_includes_decl_storage::hidden_include::storage::StoragePrefixedMap<()>
        for Revocations
    {
        fn module_prefix() -> &'static [u8] {
            < __InherentHiddenInstance as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > :: PREFIX . as_bytes ()
        }
        fn storage_prefix() -> &'static [u8] {
            b"Revocations"
        }
    }
    impl self :: sp_api_hidden_includes_decl_storage :: hidden_include :: storage :: generator :: StorageDoubleMap < dock :: revoke :: RegistryId , dock :: revoke :: RevokeId , () > for Revocations < > { type Query = Option < () > ; type Hasher1 = self :: sp_api_hidden_includes_decl_storage :: hidden_include :: Blake2_128Concat ; type Hasher2 = self :: sp_api_hidden_includes_decl_storage :: hidden_include :: Blake2_256 ; fn module_prefix () -> & 'static [u8] { < __InherentHiddenInstance as self :: sp_api_hidden_includes_decl_storage :: hidden_include :: traits :: Instance > :: PREFIX . as_bytes () } fn storage_prefix () -> & 'static [u8] { b"Revocations" } fn from_optional_value_to_query (v : Option < () >) -> Self :: Query { v . or_else (| | Default :: default ()) } fn from_query_to_optional_value (v : Self :: Query) -> Option < () > { v } }
    pub struct Module<T: Trait>(::frame_support::sp_std::marker::PhantomData<(T,)>);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::clone::Clone + Trait> ::core::clone::Clone for Module<T> {
        #[inline]
        fn clone(&self) -> Module<T> {
            match *self {
                Module(ref __self_0_0) => Module(::core::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::marker::Copy + Trait> ::core::marker::Copy for Module<T> {}
    impl<T: Trait> ::core::marker::StructuralPartialEq for Module<T> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::cmp::PartialEq + Trait> ::core::cmp::PartialEq for Module<T> {
        #[inline]
        fn eq(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) => match *self {
                    Module(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Module<T>) -> bool {
            match *other {
                Module(ref __self_1_0) => match *self {
                    Module(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl<T: Trait> ::core::marker::StructuralEq for Module<T> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::cmp::Eq + Trait> ::core::cmp::Eq for Module<T> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<
                    ::frame_support::sp_std::marker::PhantomData<(T,)>,
                >;
            }
        }
    }
    impl<T: Trait> core::fmt::Debug for Module<T>
    where
        T: core::fmt::Debug,
    {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            fmt.debug_tuple("Module").field(&self.0).finish()
        }
    }
    impl<T: frame_system::Config + Trait>
        ::frame_support::traits::OnInitialize<<T as frame_system::Config>::BlockNumber>
        for Module<T>
    {
    }
    impl<T: Trait> ::frame_support::traits::OnRuntimeUpgrade for Module<T> {
        fn on_runtime_upgrade() -> ::frame_support::dispatch::Weight {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "on_runtime_upgrade",
                            "core_mods::revoke",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/revoke.rs"),
                            Some(154u32),
                            Some("core_mods::revoke"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
            .put_into_storage::<<T as frame_system::Config>::PalletInfo, Self>();
            <<T as frame_system::Config>::DbWeight as ::frame_support::traits::Get<_>>::get()
                .writes(1)
        }
    }
    impl<T: frame_system::Config + Trait>
        ::frame_support::traits::OnFinalize<<T as frame_system::Config>::BlockNumber>
        for Module<T>
    {
    }
    impl<T: frame_system::Config + Trait>
        ::frame_support::traits::OffchainWorker<<T as frame_system::Config>::BlockNumber>
        for Module<T>
    {
    }
    #[cfg(feature = "std")]
    impl<T: Trait> ::frame_support::traits::IntegrityTest for Module<T> {}
    /// Can also be called using [`Call`].
    ///
    /// [`Call`]: enum.Call.html
    impl<T: Trait> Module<T> {
        /// Create a new revocation registry named `id` with `registry` metadata.
        ///
        /// # Errors
        ///
        /// Returns an error if `id` is already in use as a registry id.
        ///
        /// Returns an error if `registry.policy` is invalid.
        ///
        /// NOTE: Calling this function will bypass origin filters.
        pub fn new_registry(
            origin: T::Origin,
            id: dock::revoke::RegistryId,
            registry: dock::revoke::Registry,
        ) -> DispatchResult {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "new_registry",
                            "core_mods::revoke",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/revoke.rs"),
                            Some(154u32),
                            Some("core_mods::revoke"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            Module::<T>::new_registry_(origin, id, registry)
        }
        /// Create some revocations according to the `revoke`` command.
        ///
        /// # Errors
        ///
        /// Returns an error if `revoke.last_modified` does not match the block number when the
        /// registry referenced by `revoke.registry_id` was last modified.
        ///
        /// Returns an error if `proof` does not satisfy the policy requirements of the registry
        /// referenced by `revoke.registry_id`.
        ///
        /// NOTE: Calling this function will bypass origin filters.
        pub fn revoke(
            origin: T::Origin,
            revoke: dock::revoke::Revoke,
            proof: dock::revoke::PAuth,
        ) -> DispatchResult {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "revoke",
                            "core_mods::revoke",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/revoke.rs"),
                            Some(154u32),
                            Some("core_mods::revoke"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            Module::<T>::revoke_(origin, revoke, proof)
        }
        /// Delete some revocations according to the `unrevoke` command.
        ///
        /// # Errors
        ///
        /// Returns an error if the registry referenced by `revoke.registry_id` is `add_only`.
        ///
        /// Returns an error if `unrevoke.last_modified` does not match the block number when the
        /// registry referenced by `revoke.registry_id` was last modified.
        ///
        /// Returns an error if `proof` does not satisfy the policy requirements of the registy
        /// referenced by `unrevoke.registry_id`.
        ///
        /// NOTE: Calling this function will bypass origin filters.
        pub fn unrevoke(
            origin: T::Origin,
            unrevoke: dock::revoke::UnRevoke,
            proof: dock::revoke::PAuth,
        ) -> DispatchResult {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "unrevoke",
                            "core_mods::revoke",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/revoke.rs"),
                            Some(154u32),
                            Some("core_mods::revoke"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            Module::<T>::unrevoke_(origin, unrevoke, proof)
        }
        /// Delete an entire registry. Deletes all revcations within the registry, as well as
        /// registry metadata. Once the registy is deleted, it can be reclaimed by any party using
        /// a call to `new_registry`.
        ///
        /// # Errors
        ///
        /// Returns an error if the registry referenced by `revoke.registry_id` is `add_only`.
        ///
        /// Returns an error if `removal.last_modified` does not match the block number when the
        /// registry referenced by `removal.registry_id` was last modified.
        ///
        /// Returns an error if `proof` does not satisfy the policy requirements of the registy
        /// referenced by `removal.registry_id`.
        ///
        /// NOTE: Calling this function will bypass origin filters.
        pub fn remove_registry(
            origin: T::Origin,
            removal: dock::revoke::RemoveRegistry,
            proof: dock::revoke::PAuth,
        ) -> DispatchResult {
            let __within_span__ = {
                use ::tracing::__macro_support::Callsite as _;
                static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                    use ::tracing::__macro_support::MacroCallsite;
                    static META: ::tracing::Metadata<'static> = {
                        ::tracing_core::metadata::Metadata::new(
                            "remove_registry",
                            "core_mods::revoke",
                            ::tracing::Level::TRACE,
                            Some("pallets/core_mods/src/revoke.rs"),
                            Some(154u32),
                            Some("core_mods::revoke"),
                            ::tracing_core::field::FieldSet::new(
                                &[],
                                ::tracing_core::callsite::Identifier(&CALLSITE),
                            ),
                            ::tracing::metadata::Kind::SPAN,
                        )
                    };
                    MacroCallsite::new(&META)
                };
                let mut interest = ::tracing::subscriber::Interest::never();
                if ::tracing::Level::TRACE <= ::tracing::level_filters::STATIC_MAX_LEVEL
                    && ::tracing::Level::TRACE <= ::tracing::level_filters::LevelFilter::current()
                    && {
                        interest = CALLSITE.interest();
                        !interest.is_never()
                    }
                    && CALLSITE.is_enabled(interest)
                {
                    let meta = CALLSITE.metadata();
                    ::tracing::Span::new(meta, &{ meta.fields().value_set(&[]) })
                } else {
                    let span = CALLSITE.disabled_span();
                    {};
                    span
                }
            };
            let __tracing_guard__ = __within_span__.enter();
            Module::<T>::remove_registry_(origin, removal, proof)
        }
    }
    /// Dispatchable calls.
    ///
    /// Each variant of this enum maps to a dispatchable function from the associated module.
    pub enum Call<T: Trait> {
        #[doc(hidden)]
        #[codec(skip)]
        __PhantomItem(
            ::frame_support::sp_std::marker::PhantomData<(T,)>,
            ::frame_support::Never,
        ),
        #[allow(non_camel_case_types)]
        /// Create a new revocation registry named `id` with `registry` metadata.
        ///
        /// # Errors
        ///
        /// Returns an error if `id` is already in use as a registry id.
        ///
        /// Returns an error if `registry.policy` is invalid.
        new_registry(dock::revoke::RegistryId, dock::revoke::Registry),
        #[allow(non_camel_case_types)]
        /// Create some revocations according to the `revoke`` command.
        ///
        /// # Errors
        ///
        /// Returns an error if `revoke.last_modified` does not match the block number when the
        /// registry referenced by `revoke.registry_id` was last modified.
        ///
        /// Returns an error if `proof` does not satisfy the policy requirements of the registry
        /// referenced by `revoke.registry_id`.
        revoke(dock::revoke::Revoke, dock::revoke::PAuth),
        #[allow(non_camel_case_types)]
        /// Delete some revocations according to the `unrevoke` command.
        ///
        /// # Errors
        ///
        /// Returns an error if the registry referenced by `revoke.registry_id` is `add_only`.
        ///
        /// Returns an error if `unrevoke.last_modified` does not match the block number when the
        /// registry referenced by `revoke.registry_id` was last modified.
        ///
        /// Returns an error if `proof` does not satisfy the policy requirements of the registy
        /// referenced by `unrevoke.registry_id`.
        unrevoke(dock::revoke::UnRevoke, dock::revoke::PAuth),
        #[allow(non_camel_case_types)]
        /// Delete an entire registry. Deletes all revcations within the registry, as well as
        /// registry metadata. Once the registy is deleted, it can be reclaimed by any party using
        /// a call to `new_registry`.
        ///
        /// # Errors
        ///
        /// Returns an error if the registry referenced by `revoke.registry_id` is `add_only`.
        ///
        /// Returns an error if `removal.last_modified` does not match the block number when the
        /// registry referenced by `removal.registry_id` was last modified.
        ///
        /// Returns an error if `proof` does not satisfy the policy requirements of the registy
        /// referenced by `removal.registry_id`.
        remove_registry(dock::revoke::RemoveRegistry, dock::revoke::PAuth),
    }
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl<T: Trait> _parity_scale_codec::Encode for Call<T> {
            fn encode_to<__CodecOutputEdqy: _parity_scale_codec::Output>(
                &self,
                __codec_dest_edqy: &mut __CodecOutputEdqy,
            ) {
                match *self {
                    Call::new_registry(ref aa, ref ba) => {
                        __codec_dest_edqy.push_byte(0usize as u8);
                        __codec_dest_edqy.push(aa);
                        __codec_dest_edqy.push(ba);
                    }
                    Call::revoke(ref aa, ref ba) => {
                        __codec_dest_edqy.push_byte(1usize as u8);
                        __codec_dest_edqy.push(aa);
                        __codec_dest_edqy.push(ba);
                    }
                    Call::unrevoke(ref aa, ref ba) => {
                        __codec_dest_edqy.push_byte(2usize as u8);
                        __codec_dest_edqy.push(aa);
                        __codec_dest_edqy.push(ba);
                    }
                    Call::remove_registry(ref aa, ref ba) => {
                        __codec_dest_edqy.push_byte(3usize as u8);
                        __codec_dest_edqy.push(aa);
                        __codec_dest_edqy.push(ba);
                    }
                    _ => (),
                }
            }
        }
        impl<T: Trait> _parity_scale_codec::EncodeLike for Call<T> {}
    };
    const _: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate codec as _parity_scale_codec;
        impl<T: Trait> _parity_scale_codec::Decode for Call<T> {
            fn decode<__CodecInputEdqy: _parity_scale_codec::Input>(
                __codec_input_edqy: &mut __CodecInputEdqy,
            ) -> core::result::Result<Self, _parity_scale_codec::Error> {
                match __codec_input_edqy.read_byte()? {
                    __codec_x_edqy if __codec_x_edqy == 0usize as u8 => Ok(Call::new_registry(
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err("Error decoding field Call :: new_registry.0".into())
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err("Error decoding field Call :: new_registry.1".into())
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    )),
                    __codec_x_edqy if __codec_x_edqy == 1usize as u8 => Ok(Call::revoke(
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err("Error decoding field Call :: revoke.0".into())
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err("Error decoding field Call :: revoke.1".into())
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    )),
                    __codec_x_edqy if __codec_x_edqy == 2usize as u8 => Ok(Call::unrevoke(
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err("Error decoding field Call :: unrevoke.0".into())
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err("Error decoding field Call :: unrevoke.1".into())
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    )),
                    __codec_x_edqy if __codec_x_edqy == 3usize as u8 => Ok(Call::remove_registry(
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err(
                                        "Error decoding field Call :: remove_registry.0".into()
                                    )
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                        {
                            let __codec_res_edqy =
                                _parity_scale_codec::Decode::decode(__codec_input_edqy);
                            match __codec_res_edqy {
                                Err(_) => {
                                    return Err(
                                        "Error decoding field Call :: remove_registry.1".into()
                                    )
                                }
                                Ok(__codec_res_edqy) => __codec_res_edqy,
                            }
                        },
                    )),
                    _ => Err("No such variant in enum Call".into()),
                }
            }
        }
    };
    impl<T: Trait> ::frame_support::dispatch::GetDispatchInfo for Call<T> {
        fn get_dispatch_info(&self) -> ::frame_support::dispatch::DispatchInfo {
            match *self {
                Call::new_registry(ref id, ref registry) => {
                    let base_weight = T::DbWeight::get().reads_writes(1, 1) + 41_000_000;
                    let weight = <dyn ::frame_support::dispatch::WeighData<(
                        &dock::revoke::RegistryId,
                        &dock::revoke::Registry,
                    )>>::weigh_data(&base_weight, (id, registry));
                    let class =
                        <dyn ::frame_support::dispatch::ClassifyDispatch<(
                            &dock::revoke::RegistryId,
                            &dock::revoke::Registry,
                        )>>::classify_dispatch(&base_weight, (id, registry));
                    let pays_fee = <dyn ::frame_support::dispatch::PaysFee<(
                        &dock::revoke::RegistryId,
                        &dock::revoke::Registry,
                    )>>::pays_fee(&base_weight, (id, registry));
                    ::frame_support::dispatch::DispatchInfo {
                        weight,
                        class,
                        pays_fee,
                    }
                }
                Call::revoke(ref revoke, ref proof) => {
                    let base_weight = T::DbWeight::get()
                        .reads_writes(1, revoke.revoke_ids.len() as u64)
                        + 75_000_000
                        + get_weight_for_pauth(&proof, T::DbWeight::get());
                    let weight = <dyn ::frame_support::dispatch::WeighData<(
                        &dock::revoke::Revoke,
                        &dock::revoke::PAuth,
                    )>>::weigh_data(&base_weight, (revoke, proof));
                    let class = <dyn ::frame_support::dispatch::ClassifyDispatch<(
                        &dock::revoke::Revoke,
                        &dock::revoke::PAuth,
                    )>>::classify_dispatch(
                        &base_weight, (revoke, proof)
                    );
                    let pays_fee = <dyn ::frame_support::dispatch::PaysFee<(
                        &dock::revoke::Revoke,
                        &dock::revoke::PAuth,
                    )>>::pays_fee(&base_weight, (revoke, proof));
                    ::frame_support::dispatch::DispatchInfo {
                        weight,
                        class,
                        pays_fee,
                    }
                }
                Call::unrevoke(ref unrevoke, ref proof) => {
                    let base_weight = T::DbWeight::get()
                        .reads_writes(1, unrevoke.revoke_ids.len() as u64)
                        + 75_000_000
                        + get_weight_for_pauth(&proof, T::DbWeight::get());
                    let weight =
                        <dyn ::frame_support::dispatch::WeighData<(
                            &dock::revoke::UnRevoke,
                            &dock::revoke::PAuth,
                        )>>::weigh_data(&base_weight, (unrevoke, proof));
                    let class = <dyn ::frame_support::dispatch::ClassifyDispatch<(
                        &dock::revoke::UnRevoke,
                        &dock::revoke::PAuth,
                    )>>::classify_dispatch(
                        &base_weight, (unrevoke, proof)
                    );
                    let pays_fee =
                        <dyn ::frame_support::dispatch::PaysFee<(
                            &dock::revoke::UnRevoke,
                            &dock::revoke::PAuth,
                        )>>::pays_fee(&base_weight, (unrevoke, proof));
                    ::frame_support::dispatch::DispatchInfo {
                        weight,
                        class,
                        pays_fee,
                    }
                }
                Call::remove_registry(ref removal, ref proof) => {
                    let base_weight = T::DbWeight::get().reads_writes(1, 2)
                        + 100_000_000
                        + get_weight_for_pauth(&proof, T::DbWeight::get());
                    let weight = <dyn ::frame_support::dispatch::WeighData<(
                        &dock::revoke::RemoveRegistry,
                        &dock::revoke::PAuth,
                    )>>::weigh_data(&base_weight, (removal, proof));
                    let class = <dyn ::frame_support::dispatch::ClassifyDispatch<(
                        &dock::revoke::RemoveRegistry,
                        &dock::revoke::PAuth,
                    )>>::classify_dispatch(
                        &base_weight, (removal, proof)
                    );
                    let pays_fee = <dyn ::frame_support::dispatch::PaysFee<(
                        &dock::revoke::RemoveRegistry,
                        &dock::revoke::PAuth,
                    )>>::pays_fee(&base_weight, (removal, proof));
                    ::frame_support::dispatch::DispatchInfo {
                        weight,
                        class,
                        pays_fee,
                    }
                }
                Call::__PhantomItem(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__PhantomItem should never be used.",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::GetCallName for Call<T> {
        fn get_call_name(&self) -> &'static str {
            match *self {
                Call::new_registry(ref id, ref registry) => {
                    let _ = (id, registry);
                    "new_registry"
                }
                Call::revoke(ref revoke, ref proof) => {
                    let _ = (revoke, proof);
                    "revoke"
                }
                Call::unrevoke(ref unrevoke, ref proof) => {
                    let _ = (unrevoke, proof);
                    "unrevoke"
                }
                Call::remove_registry(ref removal, ref proof) => {
                    let _ = (removal, proof);
                    "remove_registry"
                }
                Call::__PhantomItem(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__PhantomItem should never be used.",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
        fn get_call_names() -> &'static [&'static str] {
            &["new_registry", "revoke", "unrevoke", "remove_registry"]
        }
    }
    pub use ::frame_support::traits::GetPalletVersion as _;
    impl<T: Trait> ::frame_support::traits::GetPalletVersion for Module<T> {
        fn current_version() -> ::frame_support::traits::PalletVersion {
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
        }
        fn storage_version() -> Option<::frame_support::traits::PalletVersion> {
            let key = ::frame_support::traits::PalletVersion::storage_key::<
                <T as frame_system::Config>::PalletInfo,
                Self,
            >()
            .expect("Every active pallet has a name in the runtime; qed");
            ::frame_support::storage::unhashed::get(&key)
        }
    }
    impl<T: Trait> ::frame_support::traits::OnGenesis for Module<T> {
        fn on_genesis() {
            frame_support::traits::PalletVersion {
                major: 0u16,
                minor: 1u8,
                patch: 0u8,
            }
            .put_into_storage::<<T as frame_system::Config>::PalletInfo, Self>();
        }
    }
    impl<T: Trait> ::frame_support::dispatch::Clone for Call<T> {
        fn clone(&self) -> Self {
            match *self {
                Call::new_registry(ref id, ref registry) => {
                    Call::new_registry((*id).clone(), (*registry).clone())
                }
                Call::revoke(ref revoke, ref proof) => {
                    Call::revoke((*revoke).clone(), (*proof).clone())
                }
                Call::unrevoke(ref unrevoke, ref proof) => {
                    Call::unrevoke((*unrevoke).clone(), (*proof).clone())
                }
                Call::remove_registry(ref removal, ref proof) => {
                    Call::remove_registry((*removal).clone(), (*proof).clone())
                }
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::PartialEq for Call<T> {
        fn eq(&self, _other: &Self) -> bool {
            match *self {
                Call::new_registry(ref id, ref registry) => {
                    let self_params = (id, registry);
                    if let Call::new_registry(ref id, ref registry) = *_other {
                        self_params == (id, registry)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                ::core::panicking::panic("internal error: entered unreachable code")
                            }
                            _ => false,
                        }
                    }
                }
                Call::revoke(ref revoke, ref proof) => {
                    let self_params = (revoke, proof);
                    if let Call::revoke(ref revoke, ref proof) = *_other {
                        self_params == (revoke, proof)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                ::core::panicking::panic("internal error: entered unreachable code")
                            }
                            _ => false,
                        }
                    }
                }
                Call::unrevoke(ref unrevoke, ref proof) => {
                    let self_params = (unrevoke, proof);
                    if let Call::unrevoke(ref unrevoke, ref proof) = *_other {
                        self_params == (unrevoke, proof)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                ::core::panicking::panic("internal error: entered unreachable code")
                            }
                            _ => false,
                        }
                    }
                }
                Call::remove_registry(ref removal, ref proof) => {
                    let self_params = (removal, proof);
                    if let Call::remove_registry(ref removal, ref proof) = *_other {
                        self_params == (removal, proof)
                    } else {
                        match *_other {
                            Call::__PhantomItem(_, _) => {
                                ::core::panicking::panic("internal error: entered unreachable code")
                            }
                            _ => false,
                        }
                    }
                }
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::Eq for Call<T> {}
    impl<T: Trait> ::frame_support::dispatch::fmt::Debug for Call<T> {
        fn fmt(
            &self,
            _f: &mut ::frame_support::dispatch::fmt::Formatter,
        ) -> ::frame_support::dispatch::result::Result<(), ::frame_support::dispatch::fmt::Error>
        {
            match *self {
                Call::new_registry(ref id, ref registry) => {
                    _f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["", ""],
                        &match (&"new_registry", &(id.clone(), registry.clone())) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                            ],
                        },
                    ))
                }
                Call::revoke(ref revoke, ref proof) => {
                    _f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["", ""],
                        &match (&"revoke", &(revoke.clone(), proof.clone())) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                            ],
                        },
                    ))
                }
                Call::unrevoke(ref unrevoke, ref proof) => {
                    _f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["", ""],
                        &match (&"unrevoke", &(unrevoke.clone(), proof.clone())) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                            ],
                        },
                    ))
                }
                Call::remove_registry(ref removal, ref proof) => {
                    _f.write_fmt(::core::fmt::Arguments::new_v1(
                        &["", ""],
                        &match (&"remove_registry", &(removal.clone(), proof.clone())) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                            ],
                        },
                    ))
                }
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            }
        }
    }
    impl<T: Trait> ::frame_support::traits::UnfilteredDispatchable for Call<T> {
        type Origin = T::Origin;
        fn dispatch_bypass_filter(
            self,
            _origin: Self::Origin,
        ) -> ::frame_support::dispatch::DispatchResultWithPostInfo {
            match self {
                Call::new_registry(id, registry) => {
                    <Module<T>>::new_registry(_origin, id, registry)
                        .map(Into::into)
                        .map_err(Into::into)
                }
                Call::revoke(revoke, proof) => <Module<T>>::revoke(_origin, revoke, proof)
                    .map(Into::into)
                    .map_err(Into::into),
                Call::unrevoke(unrevoke, proof) => <Module<T>>::unrevoke(_origin, unrevoke, proof)
                    .map(Into::into)
                    .map_err(Into::into),
                Call::remove_registry(removal, proof) => {
                    <Module<T>>::remove_registry(_origin, removal, proof)
                        .map(Into::into)
                        .map_err(Into::into)
                }
                Call::__PhantomItem(_, _) => {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"__PhantomItem should never be used.",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
    }
    impl<T: Trait> ::frame_support::dispatch::Callable<T> for Module<T> {
        type Call = Call<T>;
    }
    impl<T: Trait> Module<T> {
        #[doc(hidden)]
        #[allow(dead_code)]
        pub fn call_functions() -> &'static [::frame_support::dispatch::FunctionMetadata] {
            &[
                ::frame_support::dispatch::FunctionMetadata {
                    name: ::frame_support::dispatch::DecodeDifferent::Encode("new_registry"),
                    arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("id"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                                "dock::revoke::RegistryId",
                            ),
                        },
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("registry"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                                "dock::revoke::Registry",
                            ),
                        },
                    ]),
                    documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        r" Create a new revocation registry named `id` with `registry` metadata.",
                        r"",
                        r" # Errors",
                        r"",
                        r" Returns an error if `id` is already in use as a registry id.",
                        r"",
                        r" Returns an error if `registry.policy` is invalid.",
                    ]),
                },
                ::frame_support::dispatch::FunctionMetadata {
                    name: ::frame_support::dispatch::DecodeDifferent::Encode("revoke"),
                    arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("revoke"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                                "dock::revoke::Revoke",
                            ),
                        },
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("proof"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                                "dock::revoke::PAuth",
                            ),
                        },
                    ]),
                    documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        r" Create some revocations according to the `revoke`` command.",
                        r"",
                        r" # Errors",
                        r"",
                        r" Returns an error if `revoke.last_modified` does not match the block number when the",
                        r" registry referenced by `revoke.registry_id` was last modified.",
                        r"",
                        r" Returns an error if `proof` does not satisfy the policy requirements of the registry",
                        r" referenced by `revoke.registry_id`.",
                    ]),
                },
                ::frame_support::dispatch::FunctionMetadata {
                    name: ::frame_support::dispatch::DecodeDifferent::Encode("unrevoke"),
                    arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("unrevoke"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                                "dock::revoke::UnRevoke",
                            ),
                        },
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("proof"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                                "dock::revoke::PAuth",
                            ),
                        },
                    ]),
                    documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        r" Delete some revocations according to the `unrevoke` command.",
                        r"",
                        r" # Errors",
                        r"",
                        r" Returns an error if the registry referenced by `revoke.registry_id` is `add_only`.",
                        r"",
                        r" Returns an error if `unrevoke.last_modified` does not match the block number when the",
                        r" registry referenced by `revoke.registry_id` was last modified.",
                        r"",
                        r" Returns an error if `proof` does not satisfy the policy requirements of the registy",
                        r" referenced by `unrevoke.registry_id`.",
                    ]),
                },
                ::frame_support::dispatch::FunctionMetadata {
                    name: ::frame_support::dispatch::DecodeDifferent::Encode("remove_registry"),
                    arguments: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("removal"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                                "dock::revoke::RemoveRegistry",
                            ),
                        },
                        ::frame_support::dispatch::FunctionArgumentMetadata {
                            name: ::frame_support::dispatch::DecodeDifferent::Encode("proof"),
                            ty: ::frame_support::dispatch::DecodeDifferent::Encode(
                                "dock::revoke::PAuth",
                            ),
                        },
                    ]),
                    documentation: ::frame_support::dispatch::DecodeDifferent::Encode(&[
                        r" Delete an entire registry. Deletes all revcations within the registry, as well as",
                        r" registry metadata. Once the registy is deleted, it can be reclaimed by any party using",
                        r" a call to `new_registry`.",
                        r"",
                        r" # Errors",
                        r"",
                        r" Returns an error if the registry referenced by `revoke.registry_id` is `add_only`.",
                        r"",
                        r" Returns an error if `removal.last_modified` does not match the block number when the",
                        r" registry referenced by `removal.registry_id` was last modified.",
                        r"",
                        r" Returns an error if `proof` does not satisfy the policy requirements of the registy",
                        r" referenced by `removal.registry_id`.",
                    ]),
                },
            ]
        }
    }
    impl<T: 'static + Trait> Module<T> {
        #[doc(hidden)]
        #[allow(dead_code)]
        pub fn module_constants_metadata(
        ) -> &'static [::frame_support::dispatch::ModuleConstantMetadata] {
            &[]
        }
    }
    impl<T: Trait> ::frame_support::dispatch::ModuleErrorMetadata for Module<T> {
        fn metadata() -> &'static [::frame_support::dispatch::ErrorMetadata] {
            <RevErr<T> as ::frame_support::dispatch::ModuleErrorMetadata>::metadata()
        }
    }
    impl<T: Trait> Module<T> {
        fn new_registry_(
            origin: <T as system::Config>::Origin,
            id: RegistryId,
            registry: Registry,
        ) -> DispatchResult {
            ensure_signed(origin)?;
            {
                if !registry.policy.valid() {
                    {
                        return Err(RevErr::<T>::InvalidPolicy.into());
                    };
                }
            };
            {
                if !!Registries::<T>::contains_key(&id) {
                    {
                        return Err(RevErr::<T>::RegExists.into());
                    };
                }
            };
            Registries::<T>::insert(&id, (registry, system::Module::<T>::block_number()));
            Ok(())
        }
        fn revoke_(
            origin: <T as system::Config>::Origin,
            revoke: Revoke,
            proof: PAuth,
        ) -> DispatchResult {
            ensure_signed(origin)?;
            let registry = Self::ensure_registry_exists_and_payload_fresh(
                &revoke.registry_id,
                revoke.last_modified,
            )?;
            Self::ensure_auth(
                &crate::StateChange::Revoke(revoke.clone()),
                &proof,
                &registry.policy,
            )?;
            for cred_id in &revoke.revoke_ids {
                Revocations::insert(&revoke.registry_id, cred_id, ());
            }
            Registries::<T>::insert(
                &revoke.registry_id,
                (registry, system::Module::<T>::block_number()),
            );
            Ok(())
        }
        fn unrevoke_(
            origin: <T as system::Config>::Origin,
            unrevoke: UnRevoke,
            proof: PAuth,
        ) -> DispatchResult {
            ensure_signed(origin)?;
            let registry = Self::ensure_registry_exists_and_payload_fresh(
                &unrevoke.registry_id,
                unrevoke.last_modified,
            )?;
            {
                if !!registry.add_only {
                    {
                        return Err(RevErr::<T>::AddOnly.into());
                    };
                }
            };
            Self::ensure_auth(
                &crate::StateChange::UnRevoke(unrevoke.clone()),
                &proof,
                &registry.policy,
            )?;
            for cred_id in &unrevoke.revoke_ids {
                Revocations::remove(&unrevoke.registry_id, cred_id);
            }
            Registries::<T>::insert(
                &unrevoke.registry_id,
                (registry, system::Module::<T>::block_number()),
            );
            Ok(())
        }
        fn remove_registry_(
            origin: <T as system::Config>::Origin,
            removal: RemoveRegistry,
            proof: PAuth,
        ) -> DispatchResult {
            ensure_signed(origin)?;
            let registry = Self::ensure_registry_exists_and_payload_fresh(
                &removal.registry_id,
                removal.last_modified,
            )?;
            {
                if !!registry.add_only {
                    {
                        return Err(RevErr::<T>::AddOnly.into());
                    };
                }
            };
            Self::ensure_auth(
                &crate::StateChange::RemoveRegistry(removal.clone()),
                &proof,
                &registry.policy,
            )?;
            Revocations::remove_prefix(&removal.registry_id);
            Registries::<T>::remove(&removal.registry_id);
            Ok(())
        }
        /// Check whether `proof` authorizes `command` according to `policy`.
        ///
        /// Returns Ok if command is authorzed, otherwise returns Err.
        fn ensure_auth(
            command: &crate::StateChange,
            proof: &PAuth,
            policy: &Policy,
        ) -> DispatchResult {
            match policy {
                Policy::OneOf(controllers) => {
                    {
                        if !(proof.len() == 1
                            && proof.keys().all(|verifier| controllers.contains(verifier)))
                        {
                            {
                                return Err(RevErr::<T>::NotAuthorized.into());
                            };
                        }
                    };
                }
            }
            let payload = command.encode();
            for (signer, sig) in proof {
                let valid = did::Module::<T>::verify_sig_from_did(&sig, &payload, &signer)?;
                {
                    if !valid {
                        {
                            return Err(RevErr::<T>::NotAuthorized.into());
                        };
                    }
                };
            }
            Ok(())
        }
        /// Ensure that the registry exists and this is not a replayed payload by checking the equality
        /// with stored block number when the registry was last modified.
        fn ensure_registry_exists_and_payload_fresh(
            registry_id: &RegistryId,
            last_modified_in_block: crate::BlockNumber,
        ) -> Result<Registry, DispatchError> {
            let (registry, last_modified_actual) =
                Registries::<T>::get(registry_id).ok_or_else(|| RevErr::<T>::NoReg)?;
            {
                if !(T::BlockNumber::from(last_modified_in_block) == last_modified_actual) {
                    {
                        return Err(RevErr::<T>::DifferentBlockNumber.into());
                    };
                }
            };
            Ok(registry)
        }
    }
}
